# 데이터베이스 인덱스란?

`추가적인 저장공간을 사용해서 테이블 검색 속도를 향상 시키기 위한 자료구조입니다.`

- 데이터베이스 인덱스에는 데이터의 키와 해당 데이터의 물리적인 위치가 나타있습니다.
- 인덱스는 일반적으로 SELECT 쿼리의 WHERE 절에 사용될 컬럼에 대한 조회 성능을 개선할 때 사용됩니다.

# 인덱스를 왜 사용할까?


인덱스는 키 값에 대해 데이터의 물리적인 위치만을 가지고 있기 때문에 실제 테이블 크기에 비해 굉장히 작습니다.

테이블의 크기가 클수록 원하는 데이터를 찾아오는데 오래 걸립니다. 특히나 테이블의 전체 정보를 보조 기억장치

에서 가져오는 I/O 성능은 메모리에서 가져오는 것보다 더욱 오래걸리게 됩니다.

반면 인덱스 정보를 메모리에 적재하고 원하는 데이터의 물리적 주소를 찾아 최소한의  I/O 가 발생하기 때문에 인덱스를 사용합니다.

# 인덱스 알고리즘


### 해시 테이블

해시 테이블은 key 값에 대해 value 값을 저장하는 자료구조로 탐색시간이 O(1) 입니다.

이것만 보면 인덱스 자료구조를 구성하는데 유리해보이지만 해시 테이블의 경우 범위 탐색의 경우 범위를 모두 봐야합니다. 이러한 이유로 인덱스 자료구조를 구성하는데 불리합니다.

### 정렬된 리스트

정렬된 리스트의 조회 성능은 O(logN)입니다. 하지만 삽입과 삭제 비용이  O(N) 만큼 걸린다는 단점이 있습니다.

### 균형 트리

트리로 인덱스를 구성하는 경우 삽입 , 삭제 , 조회 모두 O(logN) 을 기대할 수 있습니다. 하지만 트리가 편향될 수 있는 경우 정렬된 리스트와 비슷해질 수 있어 트리로 구성하는 이점을 얻지 못하게됩니다.

- B-Tree : 리프 노드가 모두 같은 레벨을 갖는다는 특징이 있습니다.
    - 하나의 노드에 여러 데이터를 가질 수 있는데 노드내 데이터를 키라고 부릅니다. 각 노드의 키들은 좌우로 다른 노드를 가리키는 포인터를 가지고 있고 내부 키들은 모두 정렬된 상태를 유지합니다.
    - 노드의 각 키는 실제 데이터의 물리적인 위치를 가리키고 있는 데이터 포인터를 가지고 있습니다.
    - 키를 기준으로 데이터를 탐색한 뒤 일치하는 키를 발견한 경우 데이터 포인터가 가르키는 곳으로 이동해 실제 데이터를 찾을 수 있습니다.
- B+Tree : B+Tree 는 B-Tree 에 비해 오직 리프 노드만 데이터포인터를 가지고 있습니다.
    - 하나의 노드에서 키만을 관리하기 때문에 더 많은 키값을 저장할 수 있고 이는 더 낮은 트리 높이를 가질 수 있음을 의미합니다.
    - B+Tree 는 리프노드를 연결리스트로 연결하여 순차검색에 유리합니다.
    

# 트레이드 오프


인덱스는 추가적인 저장 공간과 쓰기 작업을 희생하는 대신 조회 성능을 얻은 것입니다.

때문에 삽입 / 삭제 / 수정 등 쓰기 작업이 빈번히 발생하는 인덱스 컬럼은 오히려 성능의 저하로 이어질 수 있습니다.

또한 인덱스는 결국 전체 테이블 스캔에서 탐색 범위를 좁혀 적은 수의 디스크 I/O 를 위한 것입니다.

인덱스 컬럼의 분포도가 집중적이거나 도메인 값이 한정적인 경우 등 탐색 범위를 충분히 좁히지 못하면 인덱스로부터 얻는 성능 이점을 누리지 못할 수도 있습니다.

# 클러스터 인덱스


클러스터 인덱스란 테이블 전체가 정렬된 인덱스가 되는 방식의 인덱스 종류입니다.

데이터 값에 따라 실제 물리적인 저장 위치가 결정됩니다

- 클러스터 인덱스는 NULL 값이 아니여야하고 Unique 해야합니다. MySQL 에서 PK 가 클러스터 인덱스입니다.
- 클러스터 인덱스 값에 따라 물리적인 저장 위치가 결정되므로 삽입 , 삭제 , 수정시 성능상에 이슈가 발생할 수 있습니다
- PK 를 활용한 데이터 검색이 빠르다는 장점이 있습니다.
