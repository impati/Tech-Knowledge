# 데이터 무결성

 데이터의 정확성 , 유효성 , 일관성이 유지되는 것을 말합니다.

# 트랜잭션이란 ?

하나의 논리적인 작업의 단위를 구성하는 일련의 연산들의 집합을 트랜잭션이라고 합니다.

# 트랜잭션은 왜 필요한가

데이터의 무결성을 유지하기 위해서 트랜잭션이 필요합니다.

예를 들어 계좌에서 특정 금액을 인출하고 다른 계좌에 입금한다고 했을 때 이 과정에서 인출 후 에러에 의해 입금이 실행되지 않았다고 했을 때 인출만 발생한 데이터 무결성에 문제가 발생할 수 있습니다.

이러한 문제 때문에 인출과 입금이 하나의 연산으로 취급되는 하나의 논리적인 작업의 단위가 필요했고 이것이 트랜잭션이 필요한 이유입니다.

# 트랜잭션 성질 ACID

트랜잭션은 데이터 무결성을 유지하기 위해 다음 4가지 성질을 가집니다.

- 원자성 : 트랜잭션에 포함된 작업은 모두 수행되거나 모두 수행되지 않아야한다.
- 일관성 : 트랜잭션을 수행하기 전 , 후로 데이터 일관성은 항상 유지해야한다.
- 고립성 : 수행 중인 트랜잭션은 다른 트랜잭션에 의해 데이터 일관성이 깨지는 일이 없어야한다.
- 지속성 : 수행을 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야한다. 저장된 데이터베이스는 저장 직후 또는 어느때나 발생할 수 있는 장애나 오류에 대해 영향을 받지 않아야한다.

# 트랜잭션의 과정과 상태

## 성공

1. 데이터베이스의 데이터를 주기억 장치 버퍼로 읽어옵니다. **<트랜잭션 시작>**
2. 트랜잭션을 수행합니다. **<트랜잭션 Active>**
3. 트랜잭션 커밋 **<부분 완료>**
4. 주 기억장치 버퍼에서 데이터베이스에 저장합니다. **<최종 완료>**

**트랜잭션을 수행하고 커밋하는 과정까지 부분완료. 주기억 장치 버퍼에서 데이터베이스에 저장하고난 후 최종적으로 완료됩니다.**

이때 부분 완료 이후 주기억 장치 버퍼에서 디스크에 내용을 반영하기 전에 문제가 생긴 경우에는 REDO 연산을 수행하여 디스크에 복구를 수행합니다.

## 실패

1. 데이터베이스의 데이터를 주기억 장치 버퍼로 읽어옵니다. **<트랜잭션 시작>**
2. 트랜잭션을 수행합니다. **<트랜잭션 Active>**
3. 실패 **<Rollback>**

트랜잭션을 수행하고 Commit 되지 않은 상태에서 문제가 발생했을 경우 실패로 Rollback 을 해야하는데 이 경우 주기억장치 버퍼에서 디스크로 반영되었을 경우 로그 파일을 통해 UNDO 연산을 수행해야합니다.

# 동시성 제어

현재 트랜잭션이 끝나고 다음 트랜잭션을 수행시키면 동시성을 제어할 필요 없습니다.

하지만 데이터베이스는 공유를 목적으로 하기 때문에 가능한 많은 트랜잭션을 동시에 수행시켜야합니다.

동시에 수행되는 트랜잭션은 다른 트랜잭션이 사용하고 있는 데이터를 사용하여 일관성이 훼손될 수 있습니다.

이를 위해 트랜잭션의 데이터접근을 제어하는 DBMS의 기능을 동시성 제어라고합니다.

## 락

동시성 제어를 위해서 해당 데이터가 트랜잭션 수행 중이라면 잠금을 통해 접근하지 못하도록 하는 기능을 락이라고합니다.

락을 획득한 트랜잭션은 해당 데이터를 사용할 수 있으며 획득하지 못한다면 대기해야합니다.

이는 성능에 직접적인 영향을 받기 때문에 최소로 사용해야합니다.

## 데드락

트랜잭션을 수행하기 위해 여러 데이터의 락을 획득해야합니다.

두개 이상의 트랜잭션이 각각 자신의 데이터에 대해서 락을 획득하고 서로의 데이터에 대해 락을 요청하면 무한 대기 상태인  데드락에 빠질 수 있습니다. 

# 트랜잭션 격리 수준에 따라 발생할 수 있는 문제점

- Dirty Read
    
    트랜잭션 A이 수행 중인 데이터를 트랜잭션B가 읽는 경우 발생하는 문제로 트랜잭션A 이 롤백 하는 하여 트랜잭션B는 잘못된 데이터를 읽는 경우를 말합니다.
    
- Non Repeatable Read
    
    트랜잭션A가 데이터를 읽고 트랜잭션 B이 데이터를 썼을 때 ,트랜잭션A이 다시 데이터를 읽은 경우 트랜잭션 A안에서 읽기의 결과가 같지 않은 경우를 말합니다.
    

- Phantom Read
    
    트랜잭션A 가 데이터를 읽고 트랜잭션 B이 데이터를 썼을 때 , 트랜잭션A가 다시 데이터를 읽은 경우 이전에 없던 데이터를 읽는 경우를 말합니다
    

# 트랜잭션 격리 수준

동시에 트랜잭션이 수행될 수 있는 환경에서의 트랜잭션의 데이터 무결성 유지와 성능 사이의 트레이드 오프 수준입니다. SERIALIZABLE 의 경우 무결성은 보장되지만 성능은 보장되지 않습니다. 반면에 READ UNCOMMITED 은 무결성은 보장할 수 없지만 모든 트랜잭션이 동시에 수행할 수 있으므로 성능이 보장됩니다.

- READ UNCOMMITED
    
    고립 수준이 가장 낮은 명령어로 자신의 데이터의 아무런 락을 걸지 않습니다. 또 다른 트랜잭션이 대기하지 않고 수행 중인 트랜잭션의 값을 읽고 사용할 수 있는 수준입니다.
    
    Dirty Read , Non Repeatable Read , Phantom Read 가 발생할 수 있습니다.
    
- READ COMMITED
    
    커밋이 완료된 트랜잭션의 변경사항만 다른 트랜잭션에서 조회할 수 있도록 허용하는 격리 수준입니다. Non Repeatable Read , Phantom Read 가 발생할 수 있습니다.
    
- REPEATABLE READ
    
    특정 행을 조회시 항상 같은 데이터 응답을 보장하는 격리 수준입니다.하지만 행이 추가 되는 것을 막지 않습니다. Phantom Read 가 발생할 수 있습니다.
    
- SERIALIZABLE
    
    고립 수준이 가장 높은 명령어로 트랜잭션이 동시에 수행될 수 없는 수준입니다.
    
    단순한 SELECT 쿼리가 실행되더라도 데이터베이스 락이 걸려 다른 트랜잭션에서 데이터를 접근할 수 없게됩니다.
    

# 회복

**회복은 데이터베이스 장애가 발생했을 때 데이터베이스의 데이터 무결성을 유지하기 위한 DBMS 기능입니다.**

장애 유형에는 시스템 충돌 , 자연재해 , 응용 소프트웨어 오류 등이 있습니다.

트랜잭션은 회복의 단위입니다. 트랜잭션은 변경 내용을 한순간에 모두 데이터베이스에 기록하지 않고

먼저 변경 내용을 로그에 기록한 후 데이터베이스에 저장합니다.

DBMS는 이 로그 내용을 참조하여 변경 내용을 모두 반영하거나 모두 롤백합니다.

로그 내용에 커밋 연산이 있고 데이터베이스에 반영되지 않은 경우 재실행을.(REDO)

로그 내용에 커밋 연산이 없는 경우에는 트랜잭션이 완료되지 않은 상태이므로 트랜잭션 취소 합니다.(UNDO)

체크 포인트는 데이터베이스의 내용과 로그파일의 내용의 동기화 시점을 로그 파일에 기록한 것입니다.
