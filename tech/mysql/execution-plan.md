대부분의 DBMS 는 많은 데이터를 안전하게 저장 및 관리하고 사용자가 원하는 데이터를 빠르게 조회할 수 있게 해주는 것이 주목적이다. 이러한 목적을 달성하려면 옵티마이저가 사용자의 쿼리를 최적으로 처리될 수 있게 하는 쿼리 실행 계획을 수립할 수 있어야한다. 하지만 옵티마이저가 관리자나 사용자의 개입 없이 항상 좋은 실행 계획을 만들어낼 수 있는 것은 아니다.  DBMS 서버는 이러한 문제점을 관리자나 사용자가 보완할 수 있도록 EXPLAIN 명령으로 수립한 계획을 확인할 수 있게해준다. 

하지만 MySQL 서버에서 보여준 실행 계획을 읽고 이해하려면 MySQL 서버가 데이터를 처리하는 로직을 이해할 필요가 있다. 

## 통계 정보

MySQL 서버는 5.7 까지 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립했다. 하지만 이는 테이블 칼럼의 값들이 실제 어떻게 분포돼 있는지에 대한 정보가 없기 때문에 실행 계획의 정확도가 떨어지는 경우가 많았다. 그래서 8.0 버전부터는 인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입되었다. 히스토그램이 도입됐다고 해서 기존 테이블이나 인덱스 통계 정보가 필요치 않은 것은 아니다.

## 테이블 및 인덱스 통계 정보

비용 기반 최적화에서 가장 중요한 것은 통계 정보이다. 통계 정보가 정확하지 않다면 엉뚱한 방향으로 쿼리를 실행할 수 있기 때문이다.

### MySQL 서버의 통계 정보

5.6 버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 **영구적으로** 관리할 수 있게 개선되었다. 그리고 각 통계 정보를 mysql 데이터베이스의 `innodb_index_status` 테이블과 `innodb_table_status` 테이블로 관리 및 볼 수 있다. 영구적인 통계 정보를 사용하는 것은 더 정확한 통계 정보를 수집할 수 있다는 것을 의미하고 이 통계 정보의 정확성에 의해 쿼리의 성능이 결정되기 때문에 시간을 투자할 가치가 있는 것이다. 이처럼 더 정확한 통계 정보를 수집하고자 한다면 `innodb_stats_persistent_sample_pages` 시스템 변수에 높은 값을 설정하면 된다. 이 값을 너무 높이면 통계 정보 수집 시간이 길어지므로 주의해야한다.

## 히스토그램

5.7 까지의 통계 정보는 단순히 인덱스된 칼럼의 유니크한 값의 개수 정도만 가지고 있었는데 이는 옵티마이저가 최적의 실행 계획을 수립하기에는 부족했다. 그래서 옵티마이저는 이러한 부족함을 채우기 위해 실행 계획을 수립할 때 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식을 사용했다. 8.0 버전으로 업그레이드되면서 MySQL 서버도 드디어 칼럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있게 되었다.

### 히스토그램 정보 수집 및 삭제

8.0 버전에서 히스토그램 정보는 칼럼 단위로 관리되는데, 이는 자동으로 수집되지 않고 `ANALYZE TABLE .. UPDATE HISTOGRAM` 명령을 실행해 수동으로 수집 및 관리된다. 수집된 히스토그램 정보는 시스템 딕셔너리에 함께 저장되고 MySQL 서버가 시작될 때 딕셔너리 히스토그램 정보를 `information_schema` 데이터베이스의 `column_statistics` 테이블로 로드한다. 그래서 실제 히스토그램 정보를 조회하려면  `column_statistics` 테이블을 SELECT 해서 조회할 수 있다.

히스토그램은 버킷 단위로 구분되어 레코드 건수나 칼럼값의 범위가 관리되는데 싱글톤 히스토그램은 칼럼이 가지는 값별로 버킷이 할당되며 높이 균형 히스토그램에서는 개수가 균등한 칼럼값의 범위별로 하나의 버킷이 할당된다. 싱글톤 히스토그램은 각 버킷이 칼럼의 값과 발생 빈도의 비율 2개의 값을 가지는 반면 높이 균형 히스토그램은 각 버킷이 범위 시작 값,마지막 값,그리고 발생 빈도 비율과 유니크한 값의 개수 등 4개의 값을 가진다.

<img width="709" alt="무제" src="https://github.com/impati/Tech-Knowledge/assets/75917903/fa9979ca-187b-4840-bc21-10c308df88af">


싱글톤 히스토그램은 주로 코드 값과 같이 유니크한 값의 개수가 상대적으로 적은 경우 사용된다. 
<img width="722" alt="무제 2" src="https://github.com/impati/Tech-Knowledge/assets/75917903/b8e752b2-059d-43cf-9711-04360775d5bb">


높이 균형 히스토그램은 칼럼값의 각 범위에 대해 레코드 건수 비율이 누적으로 표시된다. 그래서 히스토그램의 버킷 범위가 뒤로 갈수록 비율이 높아지는 것으로 보이지만 사실은 범위별로 비율이 같은 수준에서 hire_date 가 선택된 것이다. 그래프의 기울기가 일정한 것을 보면 각 범위가 비슷한 값을 가진다는 것을 알 수 있다.

### 히스토그램의 용도

히스토그램 존재 이전에는 테이블의 레코드가 1000건이고 어떤 칼럼의 유니크한 값 개수가 100개였다면 MySQL 서버는 이 칼럼에 대해 동등 비교 검색을 하면 대략 10개의 레코드가 일치할 것이라고 예측했다고 한다.

하지만 실제 응용 프로그램의 데이터는 항상 균등한 분포도를 가지지 않는다. 어떤 사용자는 주문 레코드를 많이 가지고 있고 또 다른 사용자들은 아예 없을 것이다. 그렇지만 MySQL 서버의 기존 통계 정보는 이런 부분을 고려하지 못했고 이런 단점을 극복하기 위해 히스토그램이 도입됐다. 히스토그램은 특정 칼럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않지만 각 범위별 레코드의 건수와 유니크한 값의 개수정보를 가지기 떄문에 정확한 예측을 할 수 있다.

간단히 employees 테이블의 birth_date 칼럼에 대해 히스토그램이 없을 때와 히스토그램이 있을 때의 예측이 얼마나 달라지는지 살펴보자.히스토그램 정보 없이 first_name =’Zita’ 조건에 일치하는 레코드가 224건 있고 , 그중에서 대략 11% 가 birth_date 가 1950년대 출생일 것으로 예측했다. 

히스토그램 정보를 사용하면 대략 60% 가 1950년대 생일 것으로 예측하였고 실제 데이터를 조회해보면 대략 63 % 가 1950년대 출생이었다. 단순 통계 정보만 이용한 경우와 히스토그램을 이용한 경우 차이가 매우 큰 것을 알 수 있다.

즉, 히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을 것이라고 예측한다. 이러한 차이로 쿼리의 성능은 10배 정보 차이를 보일 수 있으며, InnoDB 버퍼 풀에 데이터가 존재하지 않아서 디스크에서 읽어야하는 경우라면 그 차이는 더욱 크다. 

### 히스토그램과 인덱스

MySQL 서버에서 인덱스는 부족한 통계 정보를 수집하기 위해 사용되는 측면도 있다. MySQL 서버에서 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로 부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다. 이때 조건절에 일치하는 레코드 건수를 예측하기 위해 실제 인덱스의 B-Tree 샘플링해서 살펴본다. 이 과정을 인덱스 다이브라고한다. 일반적으로 히스토그램을 사용해서 실행 계획을 수립하는 것보다 실제 검색 조건의 대상 값에 대한 샘플링이 더 정확한 결과를 기대할 수 있기 때문에 8.0 버전에서는 주로 인덱스 되지 않은 칼럼에 대한 데이터 분포도를 참조하는 용도로 사용된다.

## 실행 계획 확인

MySQL 서버의 실행 계획은 DESC 또는 EXPLAIN 명령으로 확인할 수 있다. 그리고 8.0 부터는 EXPLAIN 명령에 사용할 수 있는 새로운 옵션이 추가되었는데 , 실행 계획의 출력 포맷과 실제 쿼리의 실행 결과 까지 확인할 수 있는 기능을 구분해서 살펴보자.

### 실행 계획 출력 포맷

이전 버전에서는 EXPLAIN EXTENDED 또는 EXPLAIN PARITIONS 명령이 구분돼 있었지만 , 8.0 부터는 모든 내용이 통합되어 보이도록 개선하면서 위의 문법은 제거되었다. 그리고 FORMAT 옵션을 사용해 실행 계획의 표시 방법을 JSON 이나 TREE 형태로 표현할 수 있다.

```kotlin
EXPLAIN FORMAT=TREE 
SELECT ...
```

### 쿼리의 실행 시간 확인

8.0.18 버전 부터는 쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있는 EXPALIN ANALYZE 기능이 추가되었다. 결과를 TREE 포맷으로 보여준다.  실행 계획에서 걸리는 시간을 나타내는 형태에서 실행 순서를 알아볼 수 있어서 좋다. EXPALIN ANALYZE 명령은 EXPLAIN 명령과 달리 실행 계획만 추출하는 것이 아니라 실제 쿼리를 실행하고 사용된 실행 계획과 소요된 시간을 보여주는 것이다. 그래서 쿼리의 실행 시간이 아주 많이 걸리는 쿼리라면 EXPALIN ANALYZE 명령이 완료되어야 결과를 확인할 수 있다. 쿼리의 실행 계획이 아주 나쁜 경우라면 EXPLIAN 명령으로 실행 계획만 확인해서 어느 정도 튜닝한 후 EXPALIN ANALYZE 명령을 실행하는 것이 좋다.

## 실행 계획 분석

## id 칼럼

하나의 SELECT 문장은 다시 1개 이상의 SELECT 문장을 포함할 수 있다. 실행 계획에서 가장 왼쪽에 표시되는 id 칼럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다.  실행 계획 순서는 EXPLAIN FORMAT = TREE 명령어를 통해 알 수 있고 indent 가 깊을 수록 먼저 실행 되었다고 볼 수 있다.

- 들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행
- 들여쓰기가 다른 레벨에서는 안쪽에 위치한 라인이 먼저 실행

## select_type 칼럼

각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼이다. 

- SIMPLE : union 이나 서브쿼리를 사용하지 않은 단순한 SELECT 쿼리
- PRIMARY : union 이나 서브쿼리를 가지는 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리
- UNION : union 으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리의 select_type 은 UNION 으로 표시된다. union 의 첫 번째 단위 SELECT 는 쿼리 결과를 모아서 저장하는 임시 테이블(DERIVED) 가 표시된다.
- DEPENDENT UNION : union 이나 union ALL 로 집합을 결합하는 쿼리에서 표시된다.  여기서 DEPENDENT 는 union 이나 union ALL 으로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미한다. 내부 쿼리가 외부의 값을 참조해서 처리될 때 DEPENDENT 키워드가 표시된다.
- UNION RESULT : UNION 결과를 담아두는 테이블을 의미한다.
- SUBQUERY : FROM 절에 사용된 서브쿼리 이외에 사용된 서브쿼리를 의미한다.
- DEPENDENT_SUBQUERY : 서브쿼리가 바깥쪽 SELECT 쿼리에서 정의된 칼럼을 사용하는 경우 표시된다.
- DERIVED : 단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다. 가능하다면 DERIVED 실행 계획의 형태를 조인으로 해결할 수 있게 쿼리를 바꿔주는 것이 좋다.
- UNCACHECABLE SUBQUERY : 하나의 쿼리 문장에 서브쿼리가 하나만 있더라도 실제 그 서브쿼리가 한 번만 실행되는 것은 아니다. 그런데 조건이 똑같은 서브쿼리가 실행될 때는 다시 실행하지 않고 이전의 실행 결과를 그대로 사용할 수 있게 서브쿼리의 결과를 내부적인 캐시 공간에 담아준다. 여기서 언급하는 서브쿼리 캐시는 쿼리 캐시나 파생 테이블과는 무관하다. select_type 이 SUBQUERY 인 경우와 UNCACHECABLE SUBQUERY 이는 캐시를 사용할 수 있느냐 없느냐에 차이가 있따. 서브쿼리에 포함된 요소에 의해 키시 자체가 불가능할 수 있는데 그럴 경우 UNCACHECABLE SUBQUERY 로 표시된다.
- MATERIALIZED : 5.6 버전부터 도입된 타입으로 FROM 절이나 IN 형태의 쿼리에 사용된 서브쿼리 최적화를 위해 사용된다.서브쿼리의 내용을 임시 테이블로 구체화한 후 임시 테이블과 드라이빙 테이블을 조인하는 형태로 최적화 처리된 경우를 말한다.

## table 칼럼

MySQL 서버의 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다. 테이블의 이름에 별칭이 부여된 경우에는 별칭으로 표시된다. 또한 table 칼럼에 <derived N> , <union M ,N> 과 같이 “<>” 으로 둘러싸인 이름이 명시된 경우 임시테이블을 의미한다.

## partitions 칼럼

파티션을 참조하는 쿼리의 경우 옵티마이저가 쿼리 처리를 위해 필요한 파티션들의 목록을 모아 표시해준다.

## type 칼럼

쿼리의 실행 계획에서 type 이후 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다. 여기서 방식이라 함은 인덱스를 사용해 레코드를 읽었는지 아니면 테이블을 처음부터 끝까지 읽었는지를 의미한다. 실행 계획에서 type 칼럼은 반드시 체크해야할 중요한 정보이다.

MySQL 에서는 하나의 테이블로부터 레코드를 읽는 작업도 조인처럼 처리한다. 그래서 SELECT 쿼리의 테이블 개수에 관계 없이 실행 계획의 type 칼럼은 조인 타입이라고 명시하고 있다. 그럼에도 type 칼럼은 각 테이블의 접근 방법으로 해석하면 된다.

type 칼럼에 표시되는 접근 방법 중 ALL 을 제외하고는 모두 인덱스를 사용하는 접근 방법이다. 하나의 단위 SELECT 쿼리는 접근 방법 중에서 단 하나만을 사용할 수 있다. 이제부터 설명할 접근 방법은 성능이 빠른 순서대로 나열된 것이다.

### const

테이블의 레코드 건수와 관계없이 프라이머리 키나 유니크 키 칼럼을 이용하는 WHERE 조건절을 가지고 있으며 반드시 1건을 반환하는 쿼리의 처리 방식을 const 라고한다. 다른 DBMS 에서는 이를 유니크 인덱스 스캔이라고도 표현한다.

이 실행계획은 옵티마이저가 쿼리를 최적화하는 단계에서 쿼리르 먼저 실행하여 쿼리 자체를 통째로 상수화한다.

### eq_ref

eq_ref 접근 방법은 여러 테이블이 조인되는 쿼리의 실행계획에서만 표시된다. 조인에서 처음 읽은 테이블의 칼럼값을 그다음 읽어야할 테이블의 프라이머리 키나 유니크 키 칼럼의 검색조건에 사용할때를 가리켜 eq_ref 라고한다 이때 두 번째 이후 읽은 테이블의 type 칼럼에 eq_ref 가 표싣된다. 또한 두 번째 이후에 읽히는 테이블을 유니크 키로 검색할 때 그 유니크 인덱스는 NOT NULL 이어야하며 다중 칼럼으로 만들어진 프라이머리 키나 유니크 인덱스라면 인덱스의 모든 칼럼이 비교조건에 사용돼야한 eq_ref 접근 방법이 사용될 수 있다. 즉, 조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근방법이다.

### ref

ref 접근 방법은 eq_ref 와 달리 조인의 순서와 관계없이 사용되며 , 또한 프라이머리 키나 유니크 키등의 제약조건도 없다. 인덱스의 종류와 관계없이 동등 조건으로 검색할 때는 ref 접근 방법이 사용된다. ref 타입은 반환되는 레코드가 반드시 1건이라는 보장이 없다

const,eq_ref , ref 의 세가지 접근 방법은 모두 WHERE 조건절에 사용하는 동등 비교 연산자여야한다는 공통점이 있다. 또한 세 가지 모두 매우 좋은 접근 방법으로 인덱스의 분포도가 나쁘지 않다면 성능상 문제를 일으키지 않는 접근 방법이다.

### fulltext

fulltext 접근 방법은  MySQL 서버의 전문 검색 인덱스를 사용해 레코드를 접근하는 방법을 의미한다.

### unique_subquery

WHERE 조건절에서 사용될 수 있는 IN(subquery) 형태의 쿼리를 위한 접근방법이다. 서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때 이 접근 방법을 선택한다.

### index_subquery

IN 연산자 특성상 IN(subquery) 또는 IN(상수 나열) 형태의 조건은 괄호 안에 있는 값의 목록 중에서 중복된 값이 먼저 제거되어야한다. IN(subquery) 에서 subquery 가 중복된 값을 반환할 수 있고 이를 인덱스를 이용하여 제거할 수 있을 때 index_subquery 접근 방법이 사용된다.

### range

인덱스 레인지 스캔 형태의 접근 방법이다. range 는 인덱스를 하나의 값이 아니라 범위로 검색하는 경우를 의미하는데 주로 “<,  >, IS NULL , BETWEEN , IN , LIKE” 등의 연산자를 이용해 인덱스를 검색할 때 사용된다. 일반적으로 어플리케이션의 쿼리가 가장 많이 사용하는 접근 방법인데 이 방법도 상당히 빠른 편이다.

### index_merge

index_merge 접근 방법은  2개 이상의 인덱스를 이용해 각각의 검색결과를 만들어낸 후 그 결과를 병합해서 처리하는 방식이다. 하지만 index_merge 접근 방식이 사용되는 경우를 생각해보면 이름만큼 그렇게 효율적으로 작동하는 것은 아니다. 

- 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방법보다 효율성이 떨어진다.
- 전문 검색 인덱스를 사용하는 쿼리에서는 적용되지 않는다.
- index_merge 접근 방법으로 처리된 결과는 항상 2개이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합 , 또는 중복 제거와 같은 부가적인 작업이 더 필요하다.

### index

인덱스 풀 스캔을 의미한다. 

index 접근 방법으 테이블을 처음부터 끝까지 읽는 풀 테이블 스캔 방식과 비교했을 때 비교하는 레코드 건수는 같다. 하지만 인덱스는 일반적으로 데이터 파일 전체보다 크기가 작으므로 인덱스 풀 스캔 시 풀 테이블 스캔보다 빠르게 처리되며 , 쿼리의 내용에 따라 정렬된 인덱스의 장점을 이용할 수 있으므로 효율적이라고할 수 있다.

- range 나 const,ref 같은 접근 방법으로 인덱스를 사용하지 못하는 경우
- 커버링 인덱스가 가능한 경우
- 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우

### ALL

테이블 풀 스캔을 으미한다. 테이블을 처음부터 끝까지 전부 읽어서 불필요한 레코드를 제거하고 반환하다.

다른 DBMS 와 같이 InnoDB 도 풀 테이블 스캔이나 인덱스 풀 스캔과 같은 대량의 I/O 를 유발하는 작업을 위해 한꺼번에 많은 페이지를 읽어 들이는 기능을 제공한다. InnoDB 에서는 리드 어헤드 라고하며 한 번에 여러 페이지를 읽어서 처리할 수 있다. 

## possible_keys 칼럼

옵티마이저가 최적의 실행 게획을 만들기위해 후보로 선정했던 접근 방법에서 사용되는 인덱스 목록일 뿐.

**사용될법했던 인덱스의 목록.**

## key 칼럼

key 칼럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다.

## key_len 칼럼

실행 계획의 key_len 칼럼 값은 쿼리를 처리하기 위해 다중 칼럼으로 구성된 인덱스에서 몇 개의 칼럼까지 사용했는지 알려준다.

## ref 칼럼

접근 방법이 ref 면 참조 조건이 어떤 값이 제공됬는지 보여준다. 상숫값을 지정했다면 ref 칼럼은 const 로 표시되고 다른 테이블의 칼럼값이면 그 테이블명과 칼럼명이 표시된다.  가끔 쿼리의 실행 계획에서 ref 칼럼 값이 func 라고 표시될 때가 있다. 이는 “Function”의 줄임말로 참조용으로 사용되는 값을 그대로 사용한 것이 아니라 콜레이션 변환이아 값 자체의 연산을 거쳐서 참조되었다는 것을 의미한다.

## rows 칼럼

옵티마이저의 실행 계획에서 각 처리 방식이 얼마나 많은 레코드를 읽고 비교해야하는지 예측해서 비용을 산정한다. 대상 테이블에 얼마나 많은 레코드가 포함돼 있는지 또는 각 인덱스값 분포도가 어떤지를 통계 정보를 기준으로 조사해서 예측한다.

MySQL 실행 계획의 rows 칼럼값은 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다. 즉 , 정확하지 않다. 또한 인덱스를 사용하는 조건에서만 일치하는 레코드 건수를 예측한다는 점이 중요하다.

## fileterd 칼럼

 filtered 칼럼의 값은 필터링되어 남은 레코드의 비율을 의미한다. 즉 , rows 가 233 이고 fileterd 값이 16.03 이라면 실제 가져와야하는 레코드는 대략 37 건정도였다는 것을 알 수 있다. 그래서 fileterd 칼럼에 표시되는 값이 얼마나 정확히 예측될 수 있느냐에 따라 조인의 성능이 다르다.

## Extra 칼럼

쿼리의 실행 계획에서 성능에 관련된 중요한 내용이 Extra 칼럼에 자주 표시된다.

### const row not found

const 접근 방법으로 읽었지만 실제로 조회된 레코드가 없는 경우

### Distinct

쿼리의 DISTINCT 를 처리하기 위해 조인하지 않아도 되는 항목은 모두 무시하고 꼭 필요한 것만 조인한 경우를 표현

### FirstMatch , LosseScan

세미 조인의 여러 최적화 중 FirstMatch , LosseScan 전략이 사용되면 표시된다.

### Impossible HAVING , WHERE

쿼리에 사용된 HAVING , WHERE 절의 조건을 만족하는 레코드가 없을 때 표시

### Using where

MySQL 엔진 레이어에서 별도의 가공을 해서 필터링 작업을 처리한 경우에 표시된다.

### Using temporay

MySQL 서버에서 쿼리를 처리하는 동안 중간 결과를 담아 두기 위해 임시 테이블을 사용한다. 임시 테이블은 메모리상에 생성될 수 있고 디스크상에 생성될 수도 있다. 

### Using index for skip scan

인덱스 스킵 스캔 최적화를 사용했을 때 표시된다.

### Using Index condition

옵티마이저가 인덱스 컨디션 푸시 다운 최적화를 사용하면 표시된다.

### Using index

커버링 인덱스를 사용했을 때 표시된다.

### Using filesort

ORDER BY 를 처리하기 위해 인덱스를 사용할 수도 있지만 적절한 인덱스를 찾지 못했을 때 MySQL 서버가 조회된 레코드를 다시 한번 정렬해야되는데 이때 정렬용 메모리 버퍼에 복사해 퀵소트 또는 힙 소트 알고리즘을 이용해 정렬을 수행했을때 표시된다.

## Reference
- [Real MySQL 8.0(1권)](https://www.yes24.com/Product/Goods/103415627)
