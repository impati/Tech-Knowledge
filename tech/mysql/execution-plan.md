대부분의 DBMS 는 많은 데이터를 안전하게 저장 및 관리하고 사용자가 원하는 데이터를 빠르게 조회할 수 있게 해주는 것이 주목적이다. 이러한 목적을 달성하려면 옵티마이저가 사용자의 쿼리를 최적으로 처리될 수 있게 하는 쿼리 실행 계획을 수립할 수 있어야한다. 하지만 옵티마이저가 관리자나 사용자의 개입 없이 항상 좋은 실행 계획을 만들어낼 수 있는 것은 아니다.  DBMS 서버는 이러한 문제점을 관리자나 사용자가 보완할 수 있도록 EXPLAIN 명령으로 수립한 계획을 확인할 수 있게해준다. 

하지만 MySQL 서버에서 보여준 실행 계획을 읽고 이해하려면 MySQL 서버가 데이터를 처리하는 로직을 이해할 필요가 있다. 

## 통계 정보

MySQL 서버는 5.7 까지 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립했다. 하지만 이는 테이블 칼럼의 값들이 실제 어떻게 분포돼 있는지에 대한 정보가 없기 때문에 실행 계획의 정확도가 떨어지는 경우가 많았다. 그래서 8.0 버전부터는 인덱스되지 않은 칼럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입되었다. 히스토그램이 도입됐다고 해서 기존 테이블이나 인덱스 통계 정보가 필요치 않은 것은 아니다.

## 테이블 및 인덱스 통계 정보

비용 기반 최적화에서 가장 중요한 것은 통계 정보이다. 통계 정보가 정확하지 않다면 엉뚱한 방향으로 쿼리를 실행할 수 있기 때문이다.

### MySQL 서버의 통계 정보

5.6 버전부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 **영구적으로** 관리할 수 있게 개선되었다. 그리고 각 통계 정보를 mysql 데이터베이스의 `innodb_index_status` 테이블과 `innodb_table_status` 테이블로 관리 및 볼 수 있다. 영구적인 통계 정보를 사용하는 것은 더 정확한 통계 정보를 수집할 수 있다는 것을 의미하고 이 통계 정보의 정확성에 의해 쿼리의 성능이 결정되기 때문에 시간을 투자할 가치가 있는 것이다. 이처럼 더 정확한 통계 정보를 수집하고자 한다면 `innodb_stats_persistent_sample_pages` 시스템 변수에 높은 값을 설정하면 된다. 이 값을 너무 높이면 통계 정보 수집 시간이 길어지므로 주의해야한다.

## 히스토그램

5.7 까지의 통계 정보는 단순히 인덱스된 칼럼의 유니크한 값의 개수 정도만 가지고 있었는데 이는 옵티마이저가 최적의 실행 계획을 수립하기에는 부족했다. 그래서 옵티마이저는 이러한 부족함을 채우기 위해 실행 계획을 수립할 때 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조하는 방식을 사용했다. 8.0 버전으로 업그레이드되면서 MySQL 서버도 드디어 칼럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있게 되었다.

### 히스토그램 정보 수집 및 삭제

8.0 버전에서 히스토그램 정보는 칼럼 단위로 관리되는데, 이는 자동으로 수집되지 않고 `ANALYZE TABLE .. UPDATE HISTOGRAM` 명령을 실행해 수동으로 수집 및 관리된다. 수집된 히스토그램 정보는 시스템 딕셔너리에 함께 저장되고 MySQL 서버가 시작될 때 딕셔너리 히스토그램 정보를 `information_schema` 데이터베이스의 `column_statistics` 테이블로 로드한다. 그래서 실제 히스토그램 정보를 조회하려면  `column_statistics` 테이블을 SELECT 해서 조회할 수 있다.

히스토그램은 버킷 단위로 구분되어 레코드 건수나 칼럼값의 범위가 관리되는데 싱글톤 히스토그램은 칼럼이 가지는 값별로 버킷이 할당되며 높이 균형 히스토그램에서는 개수가 균등한 칼럼값의 범위별로 하나의 버킷이 할당된다. 싱글톤 히스토그램은 각 버킷이 칼럼의 값과 발생 빈도의 비율 2개의 값을 가지는 반면 높이 균형 히스토그램은 각 버킷이 범위 시작 값,마지막 값,그리고 발생 빈도 비율과 유니크한 값의 개수 등 4개의 값을 가진다.

<img width="709" alt="무제" src="https://github.com/impati/Tech-Knowledge/assets/75917903/fa9979ca-187b-4840-bc21-10c308df88af">


싱글톤 히스토그램은 주로 코드 값과 같이 유니크한 값의 개수가 상대적으로 적은 경우 사용된다. 
<img width="722" alt="무제 2" src="https://github.com/impati/Tech-Knowledge/assets/75917903/b8e752b2-059d-43cf-9711-04360775d5bb">


높이 균형 히스토그램은 칼럼값의 각 범위에 대해 레코드 건수 비율이 누적으로 표시된다. 그래서 히스토그램의 버킷 범위가 뒤로 갈수록 비율이 높아지는 것으로 보이지만 사실은 범위별로 비율이 같은 수준에서 hire_date 가 선택된 것이다. 그래프의 기울기가 일정한 것을 보면 각 범위가 비슷한 값을 가진다는 것을 알 수 있다.

### 히스토그램의 용도

히스토그램 존재 이전에는 테이블의 레코드가 1000건이고 어떤 칼럼의 유니크한 값 개수가 100개였다면 MySQL 서버는 이 칼럼에 대해 동등 비교 검색을 하면 대략 10개의 레코드가 일치할 것이라고 예측했다고 한다.

하지만 실제 응용 프로그램의 데이터는 항상 균등한 분포도를 가지지 않는다. 어떤 사용자는 주문 레코드를 많이 가지고 있고 또 다른 사용자들은 아예 없을 것이다. 그렇지만 MySQL 서버의 기존 통계 정보는 이런 부분을 고려하지 못했고 이런 단점을 극복하기 위해 히스토그램이 도입됐다. 히스토그램은 특정 칼럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않지만 각 범위별 레코드의 건수와 유니크한 값의 개수정보를 가지기 떄문에 정확한 예측을 할 수 있다.

간단히 employees 테이블의 birth_date 칼럼에 대해 히스토그램이 없을 때와 히스토그램이 있을 때의 예측이 얼마나 달라지는지 살펴보자.히스토그램 정보 없이 first_name =’Zita’ 조건에 일치하는 레코드가 224건 있고 , 그중에서 대략 11% 가 birth_date 가 1950년대 출생일 것으로 예측했다. 

히스토그램 정보를 사용하면 대략 60% 가 1950년대 생일 것으로 예측하였고 실제 데이터를 조회해보면 대략 63 % 가 1950년대 출생이었다. 단순 통계 정보만 이용한 경우와 히스토그램을 이용한 경우 차이가 매우 큰 것을 알 수 있다.

즉, 히스토그램 정보가 없으면 옵티마이저는 데이터가 균등하게 분포돼 있을 것이라고 예측한다. 이러한 차이로 쿼리의 성능은 10배 정보 차이를 보일 수 있으며, InnoDB 버퍼 풀에 데이터가 존재하지 않아서 디스크에서 읽어야하는 경우라면 그 차이는 더욱 크다. 

### 히스토그램과 인덱스

MySQL 서버에서 인덱스는 부족한 통계 정보를 수집하기 위해 사용되는 측면도 있다. MySQL 서버에서 쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로 부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다. 이때 조건절에 일치하는 레코드 건수를 예측하기 위해 실제 인덱스의 B-Tree 샘플링해서 살펴본다. 이 과정을 인덱스 다이브라고한다. 일반적으로 히스토그램을 사용해서 실행 계획을 수립하는 것보다 실제 검색 조건의 대상 값에 대한 샘플링이 더 정확한 결과를 기대할 수 있기 때문에 8.0 버전에서는 주로 인덱스 되지 않은 칼럼에 대한 데이터 분포도를 참조하는 용도로 사용된다.
