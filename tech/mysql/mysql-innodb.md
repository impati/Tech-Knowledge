# InnoDB 스토리지 엔진 아키텍처

InnoDB 는 MySQL 에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며 , 그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

<img width="812" alt="1234" src="https://github.com/impati/Tech-Knowledge/assets/75917903/41088ea9-1c6f-4455-91a3-cc3fa8e7f944">


## 프라이머리 키에 의한 클러스터링

InnoDB 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장된다. 즉, 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻이며 , 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다. 프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레이지 스캔은 빠르게 처리될 수 있다. 결과적으로 쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정된다.

## 왜리 키 지원

InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고 , 변경 시에는 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블에 전파되고 그로 인해 데드락이 발생할 때가 많으므로 주의하는 것이 좋다.

외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 외래키는 데이터베이스 서버 운영의 불편함이 있는데 이때 foreign_key_checks 옵션은 OFF 로 하면 이러한 불편함을 어느정도 해소할 수 있다.

## MVCC

일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS 가 제공하는 기능이며 MVCC 의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는데 있다. InnoDB는 언두 로그를 이용해 이 기능을 구현한다.

InnoDB 버퍼 풀에 데이터가 있는 상태에서 Update 쿼리를 수행하게 된다면 커밋 실행 여부와 관계 없이 InnodB 버퍼풀은 새로운 값으로 업데이트한다. 그리고 디스크의 데이터 파일에는 체크 포인트나 InnoDB Write 스레드에 의해 새로운 값으로 업데이트되어 있을 수도 그렇지 않을 수도 있다. 

이때 READ_UNCOMMITED 수준은 InnoDB 버퍼풀을 읽지만 그렇지 않은 격리 수준의 경우에는 언두 영역의 데이터를 읽게된다. 이러한 과정을 DBMS에서는 MVCC 라고 표현한다. 즉, 하나의 레코드에 대해 2개의 버전이 유지되고 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 달라지는 구조이다. 

버전이 많아질 수도 있으며 예전 데이터가 삭제되지 못하고 오랫동안 관리돼야 하며 , 자연히 언두 영역이 저장되는 시스템 테이블스페이스 공간이 많이 늘어나는 상황이 발생할 수 있다.

이 상태에서 COMMIT 명령을 수행하면 InnoDB 는 더 이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만들어버린다.하지만 롤백하면 InnoDB 는 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀에 복구하고 언두 영역의 내용을 이를 필요로 하는 트랜잭션이 없는 경우 삭제해버린다.

## 잠금 없는 일관된 읽기 (No-Locking Consistent Read)

InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행합니다. 잠금을 걸지 않기 때문에 InnoDB 에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고 읽기 작업이 가능하다. 격리 수준이 SERIALIZABLE 이 아닌 다른 수준인 경우 INSERT 와 연결되지 않은 순수한 읽기 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 실행한다. InnoDB 에서는 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용한다.

오랜 시간 동안 활성 상태인 트랜잭션으로 인해 MySQL 서버가 느려지거나 느려지는 문제가 가끔 발생할 수 있는데 바로 이러한 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야하기 때문에 발생하는 문제다. 따라서 트랜잭션이 시작됐다면 가능한 빨리 롤백이나 커밋을 통해 트랜잭션을 완료하는 것이 좋다.

## 자동 데드락 감지

InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리한다. InnoDB 엔진은 데드락 감지 스레드를 가지고 있어서 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아서 그 중 하나를 강제 종료한다. 이때 어느 트랜잭션을 먼저 강제 종료할 것인지 판단하는 기준은 언두 로그 양이며 , 언두 로드 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상이 된다.

트랜잭션이 언두 레코드를 적게 가졌다는 이야기는 롤백을 해도 언두 처리를 해야할 내용이 적다는 것을 의미하며 , 트랜잭션 강제 롤백으로 인한 MySQL 서버의 부하도 덜 유발하기 때문이다.

일반적인 서비스에서는 데드락 감지 스레드가 트랜잭션 잠금 목록을 검사해서 데드락을 찾아내는 작업이 크게 부담되지는 않는다. 하지만 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려진다. 왜냐하면 잠금 목록을 검사해야하기 때문에 잠금 상태가 변경되지 않도록 잠금 목록이 저장된 리스트에 새로운 잠금을 걸고 데드락 스레드를 찾게 된다.데드락 감지 스레드가 느려지면 서비스 쿼리를 처리 중인 스레드는 더는 작업을 진행하지 못하고 대기하면서 서비스에 악영향을 미치게된다. 이렇게 동시 처리 스레드가 매우 많은 경우 데드락 감지 스레드는 더 많은 CPU 자원을 소모할 수도 있다.

이러한 문제를 해결하기 위해 MySQL 서버는 innodb_deadlock_detect 시스템 변수를 제공하며 OFF 로 설정하면 더이상 데드락 감지 스레드는 동작하지 않는다. 데드락 감지 스레드가 동작하지 않으면 InnoDB 엔진 내부에서 2개 이상의 트랜잭션이 상대방이 가진 잠금을 요구하는 상황이 발생해도 중재하지 않기 때문에 무한정 대기하게 될 것이다. 하지만 inndb_lock_wait_timeout 시스템 변수를 활성화하면 이런 데드락 상황에 일정시간이 지난 후 실패하게 되고 에러 메시지를 반환하게 된다.

> 구글에서는 프라이머리 키 기반의 조회 및 변경이 높은 빈도로 많았는데 , 서비스의 매우 많은 트랜잭션이 동시에 발생하기 때문에 데드락 감지 스레드가 상당히 성능을 저하시킨다는 것을 알아냈다. 그리고 MySQL 소스코드를 변경해 데드락 감지 스레드 활성화 ,비활성화를 변경할 수 있게 한 뒤 사용해 성능 개선을 이뤄낸 사례가 있다.
> 

## 자동화된 장애 복구

InnoDB 에는 손실이나 장애로부터 데이터를 보호하기 위한 여러가지 매커니즘이 탑재되어 있다. 그러한 매커니즘을 이용해 MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행된다.

InnoDB 엔진은 매우 견고해서 데이터 파일이 손상되거나 MySQL 서버가 시작되지 못하는 경우는 거의 발생하지 않는다. 하지만 MySQL 서버와 무관하게 디스크나 서버 하드웨어 이슈로 InnoDB 엔진이 자동으로 복구하지 못하는 경우가 발생할 수도 있다.

이때는 MySQL 서버의 설정파일에 innodb_force_recovery 시스템 변수를 설정해서 MySQL 서버를 시작해야한다. 이 설정값은 MySQL 서버가 시작될 때 InnoDB 엔진이 데이터파일이나 로그 파일의 손상 여부를 진행할 수 있게한다.

일단 MySQL 서버가 기동되고 InnoDB 테이블이 인식된다면 mysqldump 를 이용해 데이터를 가능한 만큼 백업하고 그 데이터로 MySQL 서버의 DB 와 테이블을 다시 생성하는 것이 좋다. InnoDB 복구를 위해 inndo_force_recovery 옵션에 설정값은 1부터 6까지 인데 0이 아닌 복구 모드에서는 SELECT 이외 DML 쿼리를 사용할 수 없다.

1부터 6까지 복구모드를 진행했음에도 MySQL 서버가 시작되지 않으면 백업을 이용해 다시 구축하는 방법밖에 없다. 백업이 있다면 마지막 백업으로 데이터베이스를 새로 구축하고 바이너리 로그를 사용해 최대한 장애 시점까지 데이터를 복구할 수도 있다. 마지막 풀 백업 시점부터 바이너리 로그가있다면 InnoDB의 복구를 이용하는 것보다 풀 백업과 바이너리 로그로 복구하는 편이 데이터 손실이 더 적을 수 있다. 백업은 있지만 바이너리 로그가 없거나 손실되었다면 마지막 백업 시점까지만 복구할 수 있다.


## InnoDB 버퍼 풀

InnoDB 엔진에서 가장 핵심적인 부분으로 디스크의 데이터파일이나 인덱스 정보를 메모리에 캐시해두는 공간이다.

쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이한다. 일반적인 어플리케이션에서는 INSERT , UPDATE,DELETE 처럼 데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킨다. 하지만 버퍼 풀이 이러한 변경된 데이터를 모아서 처리하면 랜덤한 디스크 작업의 횟수를 줄일 수 있다.

### 버퍼 풀의 크기 설정

운영체제와 각 클라이언트스레드가 사용할 메모리와 함께 고려해서 설정해야한다.MySQL 서버 내에서 메모리를 필요로 하는 부분은 크게 없지만 아주 독톡한 경우 레코드 버퍼가 상당한 메모리를 사용하고는 한다.

**레코드 버퍼**는 각 클라이언트 세션에서 테이블의 레코드를 읽고 슬 때 버퍼로 사용하는 공간을 말하는데 , 커넥션이 많고 사용하는 테이블도 많다면 레코드 버퍼 용도로 사용되는 메모리 공간이 꽤 필요해질 수 있다. 

MySQL 5.7 부터는 버퍼 풀의 크기를 동적으로 조절할 수 있게 개선되었다. 그래서 가능하면 InnoDB 버퍼 풀 크기를 적절히 작은 값에서 부터 시작해서 조금씩 증가시키는 방법이 좋다.

InnoDB 버퍼 풀은 innodb_buffer_pool_size 시스템 변수로 크기를 설정할 수 있으며 동적으로 버퍼 풀의 크기를 확장할 수 있다.InnoDB 버퍼 풀은 내부적으로 128MB 청크 단위로 쪼개어 관리되는데 , 이는 버퍼 풀의 크기를 줄이거나 늘리기 위한 단위 크기로 사용된다.

InnoDB 버퍼 풀은 전통적으로 버퍼 풀 전체를 관리하는 잠금으로 인해 내부 잠금 경함이 많이 유발해왔는데 이런 경합을 줄이기 위해 버퍼 풀을 여러 개로 쪼개어 관리할 수 있도록 개선되었다. 이는 innodb_buffer_pool_instances 시스템 변수를 이용해 버퍼 풀을 여러 개로 분리해서 관리할 수 있다. 메모리 크기가 1GB 미만이면 버퍼 풀 인스턴스는 1개만 , 40GB 이하라면 8개 , 메모리 크기가 충분히 크다면 인스턴스 당 5GB 정도가 되게 인스턴스 개수를 설정하는 것이 좋다.

### 버퍼 풀의 구조

InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장한다. 버퍼 풀의 페이지 크기 조각을 관리하기 위해 InnoDB 스토리지 엔진은 크게 LRU 리스트와 플러시 리스트 , 프리 리스트라는 3개의 자료구조를 이용한다. 

먼저 프리 리스트는 InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지의 목록이며 사용자의 쿼리가 새롭게 디스크의 페이지를 읽어와야하는 경우 사용된다.

LRU 리스트는 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀의 메모리에 유지해서 디스크 읽기를 최소화하는 것이다. 

처음 한 번 읽힌 데이터 페이지가 이후 자주 사용된다면 그 데이터 페이지는 InnoDB 버퍼 풀의 MRU 영역에서 계속 살아남게 되고 반대로 거의 사용되지 않는다면 새롭게 디스크에서 읽히는 데이터 페이지들에 밀려서 InnoDB 버퍼 풀에서 제거될 것이다.

### 버퍼 풀과 리두 로그

InnoDB의 버퍼 풀과 리두 로그는 매우 밀접한 관계를 맺고 있다. InnoDB의 버퍼 풀은 서버의 메모리가 허용하는 만큼 크게 설정할 수록 쿼리 성능이 빨라진다. 물론 이미 디스크의 모든 데이터 파일이 버퍼 풀에 적재될 정도의 버퍼 풀 공간이라면 더는 버퍼 풀 크기를 늘려도 성능에 도움이 되지 않겠지만.

InnoDB 버퍼 풀은 데이터베이스 서버의 성능 향상을 위해 데이터 캐시와 쓰기 버퍼링이라는 두 가지 용도가 있는데 버퍼 풀의 메모리 공간만 단순히 늘리는 것은 데이터 캐시 기능만 향상 시키는 것이다. InnoDB 버퍼풀의 쓰기 버퍼링 기능까지 향상시키면 InnoDB 버퍼풀과 리두 로그와의 관계를 먼저이해해야한다.

InnoDB 버퍼풀은 디스크에서 읽은 상태로 전혀 변경되지 않은 클린 페이지와 함께 INSERT , DELETE,UPDATE 명령으로 변경된 데이터를 가진 더티페이지도 가지고 있다. 더티 페이지는 디스크와 메모리의 데이터 상태가 다르기 때문에 언젠가는 디스크로 기록돼야한다. 하지만 더티 페이지는 버퍼 풀에 무한정 머무를 수 있는 것이 아니다. InnoDB 엔진에서 리두 로그는 1개 이상의 고정 파일을 연결해서 순환 고리처럼 사용한다.즉, 데이터 변경이 계속 발생하면 리두 로드 파일에 기록됐던 로그 엔트리는 어느 순간 새로운 로그 엔트리로 덮어 쓰인다. 그래서 InnoDB 엔진은 전체 리두 로그 파일에서 재사용 가능한 공간과 당장 재사용 불가능한 공간을 구분해서 관리해야하는데 재사용 불가능한 공간을 활성 리두 로그 라고한다.

리두 로그 파일의 공간은 계속 순환되어 재사용되지만 매번 기록될 때마다 로그 포지션은 계속 증가하는 값을 가지게 되는데 이를 LSN (Log Sequence Number)이라고한다. InnoDB엔진은 주기적으로 체크 포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화한다. 이렇게 발생한 체크포인트 중 가장 최근 체크 포인트 지점의 LSN이 활성 리두 로그 공간의 시작점이 된다. 하지만 활성 리두 로그 공간의 마지막은 계속해서 증가하기 때문에 체크 포인트와 무곤하고 가장 최근 체크 포인트의 LSN 과 미지막 리두 로그 엔트리의 LSN 차이를 체크포인트 에이지라고 한다. 즉, 체크포인트 에이지는 활성 리두 로그 공간의 크기를 일컫는다.

InnoDB 버퍼 풀의 더티 페이지는 특정 리두 로그 엔트리와 관계를 가지고 , 체크 포인트가 발생하면 체크 포인트 LSN 보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크에 동기화되어야한다.즉, 리두 로그 파일의 크기와 평균 리두 엔트리 크기에 따라 터티 페이지 크기가 결정된다. 예를 들어 리두 로그 파일의 크기가 100GB 이고 평균 리두 로그 엔트리 크기가 4KB 였다면 더티 페이지는 400GB 정도까지 가지고 있을 수 있다.

### 버퍼 풀 플러시

InnoDB 엔진은 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 2개의 플러시 기능을 백그라운드로 실행한다.

- 플러시 리스트 플러시
    
    InnoDB 엔진은 리두 로그 공간의 재활용을 위해 주기적으로 오래된 리두 로그 엔트리가 사용하는 공간을 비워야한다. 그런데 이때 오랜된 리두 로그 공간이 비워질려면 반드시 InnoDB 버퍼풀의 더티 페이지가 먼저 디스크로 동기화되어야한다. 이를 위해 InnoDB 엔진은 주기적으로 **플러시 리스트 플러시** 함수를 호출해서 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행한다. 이때 얼마나 많은 더티페이지를 한 번에 디스크로 기록하느냐에 따라 시스템에 미치는 영향의 정도가 달라진다.
    
    일반적으로 InnoDB 버퍼 풀은 더티 페이지를 많이 가지고 있을 수록 디스크 쓰기 작업을 버퍼링함으로써 여러번 디스크 쓰기를 한 번으로 줄이는 효과를 극대화할 수 있다. 여기서 발생할 수 있는 문제점은 InnoDB 버퍼 풀에 더티 페이지가 많으면 많을 수록 디스크 쓰기 폭발 현상이 발생할 가능성이 높아진다.
    
    InnoDB 스토리지 엔진은 innodo_io_capacity 시스템 변수에 설정된 값을 기준으로 더티 페이지 쓰기를 실행한다. 하지만 디스크로 기록되는 더티페이지 개수보다 더 많은 더티 페이지가 발생하면 버퍼 풀에 더티페이지가 계속 증가하게 되고 어느 순간 더티 페이지의 비율이 90% 넘어가면 InnoDB 엔진은 급작스럽게 더티 페이지를 디스크로 기록해야한다고 판단한다. 이러한 문제를 완화하기 위해 일정 수준의 더티 페이지가 발생하면 조금씩 더티 페이지를 디스크로 기록하게 하고 있다. 만약 더티 페이지의 비율이 얼마 되지 않은 상태에서 디스크 쓰기가 많이 발생하고 더티페이지의 비율이 너무 낮은 상태로 머물러 있다면 innodb_max_dirty_pages_lwm 시스템 변수를 조금 더 높은 겂으로 조정하는 것도 디스크 쓰기 횟수를 줄이는 효과를 얻을 수 있다.
    
- LRU 리스트 플러시
    
    InnoDB 엔진은 LRU 리스트에서 사용 빈도가 낮은 데이터 페이지를 제거해서 새로운 페이지를 읽어올 공간을 만드는데 이를 위해 LRU 리스트 플러시 함수가 사용된다. InnoDB 엔진은 LRU 리스트의 끝부분부터 시작해서 최대 innodb_lru_scan_depth 시스템 변수에 설정된 개수 만큼 페이지를 스캔한다. InnoDB 엔진은 이때 스캔하면서 더티 페이지는 디스크에 동기화하게 하며 , 클린 페이지는 즉시 프리 리스트로 페이지를 옮긴다.
