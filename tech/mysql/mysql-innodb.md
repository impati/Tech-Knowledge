# InnoDB 스토리지 엔진 아키텍처

InnoDB 는 MySQL 에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며 , 그 때문에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

<img width="812" alt="1234" src="https://github.com/impati/Tech-Knowledge/assets/75917903/41088ea9-1c6f-4455-91a3-cc3fa8e7f944">


## 프라이머리 키에 의한 클러스터링

InnoDB 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장된다. 즉, 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻이며 , 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다. 프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레이지 스캔은 빠르게 처리될 수 있다. 결과적으로 쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정된다.

## 왜리 키 지원

InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고 , 변경 시에는 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블에 전파되고 그로 인해 데드락이 발생할 때가 많으므로 주의하는 것이 좋다.

외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 외래키는 데이터베이스 서버 운영의 불편함이 있는데 이때 foreign_key_checks 옵션은 OFF 로 하면 이러한 불편함을 어느정도 해소할 수 있다.

## MVCC

일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS 가 제공하는 기능이며 MVCC 의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는데 있다. InnoDB는 언두 로그를 이용해 이 기능을 구현한다.

InnoDB 버퍼 풀에 데이터가 있는 상태에서 Update 쿼리를 수행하게 된다면 커밋 실행 여부와 관계 없이 InnodB 버퍼풀은 새로운 값으로 업데이트한다. 그리고 디스크의 데이터 파일에는 체크 포인트나 InnoDB Write 스레드에 의해 새로운 값으로 업데이트되어 있을 수도 그렇지 않을 수도 있다. 

이때 READ_UNCOMMITED 수준은 InnoDB 버퍼풀을 읽지만 그렇지 않은 격리 수준의 경우에는 언두 영역의 데이터를 읽게된다. 이러한 과정을 DBMS에서는 MVCC 라고 표현한다. 즉, 하나의 레코드에 대해 2개의 버전이 유지되고 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 달라지는 구조이다. 

버전이 많아질 수도 있으며 예전 데이터가 삭제되지 못하고 오랫동안 관리돼야 하며 , 자연히 언두 영역이 저장되는 시스템 테이블스페이스 공간이 많이 늘어나는 상황이 발생할 수 있다.

이 상태에서 COMMIT 명령을 수행하면 InnoDB 는 더 이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만들어버린다.하지만 롤백하면 InnoDB 는 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀에 복구하고 언두 영역의 내용을 이를 필요로 하는 트랜잭션이 없는 경우 삭제해버린다.

## 잠금 없는 일관된 읽기 (No-Locking Consistent Read)

InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행합니다. 잠금을 걸지 않기 때문에 InnoDB 에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고 읽기 작업이 가능하다. 격리 수준이 SERIALIZABLE 이 아닌 다른 수준인 경우 INSERT 와 연결되지 않은 순수한 읽기 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 실행한다. InnoDB 에서는 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용한다.

오랜 시간 동안 활성 상태인 트랜잭션으로 인해 MySQL 서버가 느려지거나 느려지는 문제가 가끔 발생할 수 있는데 바로 이러한 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야하기 때문에 발생하는 문제다. 따라서 트랜잭션이 시작됐다면 가능한 빨리 롤백이나 커밋을 통해 트랜잭션을 완료하는 것이 좋다.

## 자동 데드락 감지

InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리한다. InnoDB 엔진은 데드락 감지 스레드를 가지고 있어서 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아서 그 중 하나를 강제 종료한다. 이때 어느 트랜잭션을 먼저 강제 종료할 것인지 판단하는 기준은 언두 로그 양이며 , 언두 로드 레코드를 더 적게 가진 트랜잭션이 일반적으로 롤백의 대상이 된다.

트랜잭션이 언두 레코드를 적게 가졌다는 이야기는 롤백을 해도 언두 처리를 해야할 내용이 적다는 것을 의미하며 , 트랜잭션 강제 롤백으로 인한 MySQL 서버의 부하도 덜 유발하기 때문이다.

일반적인 서비스에서는 데드락 감지 스레드가 트랜잭션 잠금 목록을 검사해서 데드락을 찾아내는 작업이 크게 부담되지는 않는다. 하지만 동시 처리 스레드가 매우 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려진다. 왜냐하면 잠금 목록을 검사해야하기 때문에 잠금 상태가 변경되지 않도록 잠금 목록이 저장된 리스트에 새로운 잠금을 걸고 데드락 스레드를 찾게 된다.데드락 감지 스레드가 느려지면 서비스 쿼리를 처리 중인 스레드는 더는 작업을 진행하지 못하고 대기하면서 서비스에 악영향을 미치게된다. 이렇게 동시 처리 스레드가 매우 많은 경우 데드락 감지 스레드는 더 많은 CPU 자원을 소모할 수도 있다.

이러한 문제를 해결하기 위해 MySQL 서버는 innodb_deadlock_detect 시스템 변수를 제공하며 OFF 로 설정하면 더이상 데드락 감지 스레드는 동작하지 않는다. 데드락 감지 스레드가 동작하지 않으면 InnoDB 엔진 내부에서 2개 이상의 트랜잭션이 상대방이 가진 잠금을 요구하는 상황이 발생해도 중재하지 않기 때문에 무한정 대기하게 될 것이다. 하지만 inndb_lock_wait_timeout 시스템 변수를 활성화하면 이런 데드락 상황에 일정시간이 지난 후 실패하게 되고 에러 메시지를 반환하게 된다.

> 구글에서는 프라이머리 키 기반의 조회 및 변경이 높은 빈도로 많았는데 , 서비스의 매우 많은 트랜잭션이 동시에 발생하기 때문에 데드락 감지 스레드가 상당히 성능을 저하시킨다는 것을 알아냈다. 그리고 MySQL 소스코드를 변경해 데드락 감지 스레드 활성화 ,비활성화를 변경할 수 있게 한 뒤 사용해 성능 개선을 이뤄낸 사례가 있다.
> 

## 자동화된 장애 복구

InnoDB 에는 손실이나 장애로부터 데이터를 보호하기 위한 여러가지 매커니즘이 탑재되어 있다. 그러한 매커니즘을 이용해 MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행된다.

InnoDB 엔진은 매우 견고해서 데이터 파일이 손상되거나 MySQL 서버가 시작되지 못하는 경우는 거의 발생하지 않는다. 하지만 MySQL 서버와 무관하게 디스크나 서버 하드웨어 이슈로 InnoDB 엔진이 자동으로 복구하지 못하는 경우가 발생할 수도 있다.

이때는 MySQL 서버의 설정파일에 innodb_force_recovery 시스템 변수를 설정해서 MySQL 서버를 시작해야한다. 이 설정값은 MySQL 서버가 시작될 때 InnoDB 엔진이 데이터파일이나 로그 파일의 손상 여부를 진행할 수 있게한다.

일단 MySQL 서버가 기동되고 InnoDB 테이블이 인식된다면 mysqldump 를 이용해 데이터를 가능한 만큼 백업하고 그 데이터로 MySQL 서버의 DB 와 테이블을 다시 생성하는 것이 좋다. InnoDB 복구를 위해 inndo_force_recovery 옵션에 설정값은 1부터 6까지 인데 0이 아닌 복구 모드에서는 SELECT 이외 DML 쿼리를 사용할 수 없다.

1부터 6까지 복구모드를 진행했음에도 MySQL 서버가 시작되지 않으면 백업을 이용해 다시 구축하는 방법밖에 없다. 백업이 있다면 마지막 백업으로 데이터베이스를 새로 구축하고 바이너리 로그를 사용해 최대한 장애 시점까지 데이터를 복구할 수도 있다. 마지막 풀 백업 시점부터 바이너리 로그가있다면 InnoDB의 복구를 이용하는 것보다 풀 백업과 바이너리 로그로 복구하는 편이 데이터 손실이 더 적을 수 있다. 백업은 있지만 바이너리 로그가 없거나 손실되었다면 마지막 백업 시점까지만 복구할 수 있다.


## InnoDB 버퍼 풀

InnoDB 엔진에서 가장 핵심적인 부분으로 디스크의 데이터파일이나 인덱스 정보를 메모리에 캐시해두는 공간이다.

쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이한다. 일반적인 어플리케이션에서는 INSERT , UPDATE,DELETE 처럼 데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킨다. 하지만 버퍼 풀이 이러한 변경된 데이터를 모아서 처리하면 랜덤한 디스크 작업의 횟수를 줄일 수 있다.

### 버퍼 풀의 크기 설정

운영체제와 각 클라이언트스레드가 사용할 메모리와 함께 고려해서 설정해야한다.MySQL 서버 내에서 메모리를 필요로 하는 부분은 크게 없지만 아주 독톡한 경우 레코드 버퍼가 상당한 메모리를 사용하고는 한다.

**레코드 버퍼**는 각 클라이언트 세션에서 테이블의 레코드를 읽고 슬 때 버퍼로 사용하는 공간을 말하는데 , 커넥션이 많고 사용하는 테이블도 많다면 레코드 버퍼 용도로 사용되는 메모리 공간이 꽤 필요해질 수 있다. 

MySQL 5.7 부터는 버퍼 풀의 크기를 동적으로 조절할 수 있게 개선되었다. 그래서 가능하면 InnoDB 버퍼 풀 크기를 적절히 작은 값에서 부터 시작해서 조금씩 증가시키는 방법이 좋다.

InnoDB 버퍼 풀은 innodb_buffer_pool_size 시스템 변수로 크기를 설정할 수 있으며 동적으로 버퍼 풀의 크기를 확장할 수 있다.InnoDB 버퍼 풀은 내부적으로 128MB 청크 단위로 쪼개어 관리되는데 , 이는 버퍼 풀의 크기를 줄이거나 늘리기 위한 단위 크기로 사용된다.

InnoDB 버퍼 풀은 전통적으로 버퍼 풀 전체를 관리하는 잠금으로 인해 내부 잠금 경함이 많이 유발해왔는데 이런 경합을 줄이기 위해 버퍼 풀을 여러 개로 쪼개어 관리할 수 있도록 개선되었다. 이는 innodb_buffer_pool_instances 시스템 변수를 이용해 버퍼 풀을 여러 개로 분리해서 관리할 수 있다. 메모리 크기가 1GB 미만이면 버퍼 풀 인스턴스는 1개만 , 40GB 이하라면 8개 , 메모리 크기가 충분히 크다면 인스턴스 당 5GB 정도가 되게 인스턴스 개수를 설정하는 것이 좋다.

### 버퍼 풀의 구조

InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장한다. 버퍼 풀의 페이지 크기 조각을 관리하기 위해 InnoDB 스토리지 엔진은 크게 LRU 리스트와 플러시 리스트 , 프리 리스트라는 3개의 자료구조를 이용한다. 

먼저 프리 리스트는 InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지의 목록이며 사용자의 쿼리가 새롭게 디스크의 페이지를 읽어와야하는 경우 사용된다.

LRU 리스트는 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀의 메모리에 유지해서 디스크 읽기를 최소화하는 것이다. 

처음 한 번 읽힌 데이터 페이지가 이후 자주 사용된다면 그 데이터 페이지는 InnoDB 버퍼 풀의 MRU 영역에서 계속 살아남게 되고 반대로 거의 사용되지 않는다면 새롭게 디스크에서 읽히는 데이터 페이지들에 밀려서 InnoDB 버퍼 풀에서 제거될 것이다.

### 버퍼 풀과 리두 로그

InnoDB의 버퍼 풀과 리두 로그는 매우 밀접한 관계를 맺고 있다. InnoDB의 버퍼 풀은 서버의 메모리가 허용하는 만큼 크게 설정할 수록 쿼리 성능이 빨라진다. 물론 이미 디스크의 모든 데이터 파일이 버퍼 풀에 적재될 정도의 버퍼 풀 공간이라면 더는 버퍼 풀 크기를 늘려도 성능에 도움이 되지 않겠지만.

InnoDB 버퍼 풀은 데이터베이스 서버의 성능 향상을 위해 데이터 캐시와 쓰기 버퍼링이라는 두 가지 용도가 있는데 버퍼 풀의 메모리 공간만 단순히 늘리는 것은 데이터 캐시 기능만 향상 시키는 것이다. InnoDB 버퍼풀의 쓰기 버퍼링 기능까지 향상시키면 InnoDB 버퍼풀과 리두 로그와의 관계를 먼저이해해야한다.

InnoDB 버퍼풀은 디스크에서 읽은 상태로 전혀 변경되지 않은 클린 페이지와 함께 INSERT , DELETE,UPDATE 명령으로 변경된 데이터를 가진 더티페이지도 가지고 있다. 더티 페이지는 디스크와 메모리의 데이터 상태가 다르기 때문에 언젠가는 디스크로 기록돼야한다. 하지만 더티 페이지는 버퍼 풀에 무한정 머무를 수 있는 것이 아니다. InnoDB 엔진에서 리두 로그는 1개 이상의 고정 파일을 연결해서 순환 고리처럼 사용한다.즉, 데이터 변경이 계속 발생하면 리두 로드 파일에 기록됐던 로그 엔트리는 어느 순간 새로운 로그 엔트리로 덮어 쓰인다. 그래서 InnoDB 엔진은 전체 리두 로그 파일에서 재사용 가능한 공간과 당장 재사용 불가능한 공간을 구분해서 관리해야하는데 재사용 불가능한 공간을 활성 리두 로그 라고한다.

리두 로그 파일의 공간은 계속 순환되어 재사용되지만 매번 기록될 때마다 로그 포지션은 계속 증가하는 값을 가지게 되는데 이를 LSN (Log Sequence Number)이라고한다. InnoDB엔진은 주기적으로 체크 포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화한다. 이렇게 발생한 체크포인트 중 가장 최근 체크 포인트 지점의 LSN이 활성 리두 로그 공간의 시작점이 된다. 하지만 활성 리두 로그 공간의 마지막은 계속해서 증가하기 때문에 체크 포인트와 무곤하고 가장 최근 체크 포인트의 LSN 과 미지막 리두 로그 엔트리의 LSN 차이를 체크포인트 에이지라고 한다. 즉, 체크포인트 에이지는 활성 리두 로그 공간의 크기를 일컫는다.

InnoDB 버퍼 풀의 더티 페이지는 특정 리두 로그 엔트리와 관계를 가지고 , 체크 포인트가 발생하면 체크 포인트 LSN 보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크에 동기화되어야한다.즉, 리두 로그 파일의 크기와 평균 리두 엔트리 크기에 따라 터티 페이지 크기가 결정된다. 예를 들어 리두 로그 파일의 크기가 100GB 이고 평균 리두 로그 엔트리 크기가 4KB 였다면 더티 페이지는 400GB 정도까지 가지고 있을 수 있다.

### 버퍼 풀 플러시

InnoDB 엔진은 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 2개의 플러시 기능을 백그라운드로 실행한다.

- 플러시 리스트 플러시
    
    InnoDB 엔진은 리두 로그 공간의 재활용을 위해 주기적으로 오래된 리두 로그 엔트리가 사용하는 공간을 비워야한다. 그런데 이때 오랜된 리두 로그 공간이 비워질려면 반드시 InnoDB 버퍼풀의 더티 페이지가 먼저 디스크로 동기화되어야한다. 이를 위해 InnoDB 엔진은 주기적으로 **플러시 리스트 플러시** 함수를 호출해서 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행한다. 이때 얼마나 많은 더티페이지를 한 번에 디스크로 기록하느냐에 따라 시스템에 미치는 영향의 정도가 달라진다.
    
    일반적으로 InnoDB 버퍼 풀은 더티 페이지를 많이 가지고 있을 수록 디스크 쓰기 작업을 버퍼링함으로써 여러번 디스크 쓰기를 한 번으로 줄이는 효과를 극대화할 수 있다. 여기서 발생할 수 있는 문제점은 InnoDB 버퍼 풀에 더티 페이지가 많으면 많을 수록 디스크 쓰기 폭발 현상이 발생할 가능성이 높아진다.
    
    InnoDB 스토리지 엔진은 innodo_io_capacity 시스템 변수에 설정된 값을 기준으로 더티 페이지 쓰기를 실행한다. 하지만 디스크로 기록되는 더티페이지 개수보다 더 많은 더티 페이지가 발생하면 버퍼 풀에 더티페이지가 계속 증가하게 되고 어느 순간 더티 페이지의 비율이 90% 넘어가면 InnoDB 엔진은 급작스럽게 더티 페이지를 디스크로 기록해야한다고 판단한다. 이러한 문제를 완화하기 위해 일정 수준의 더티 페이지가 발생하면 조금씩 더티 페이지를 디스크로 기록하게 하고 있다. 만약 더티 페이지의 비율이 얼마 되지 않은 상태에서 디스크 쓰기가 많이 발생하고 더티페이지의 비율이 너무 낮은 상태로 머물러 있다면 innodb_max_dirty_pages_lwm 시스템 변수를 조금 더 높은 겂으로 조정하는 것도 디스크 쓰기 횟수를 줄이는 효과를 얻을 수 있다.
    
- LRU 리스트 플러시
    
    InnoDB 엔진은 LRU 리스트에서 사용 빈도가 낮은 데이터 페이지를 제거해서 새로운 페이지를 읽어올 공간을 만드는데 이를 위해 LRU 리스트 플러시 함수가 사용된다. InnoDB 엔진은 LRU 리스트의 끝부분부터 시작해서 최대 innodb_lru_scan_depth 시스템 변수에 설정된 개수 만큼 페이지를 스캔한다. InnoDB 엔진은 이때 스캔하면서 더티 페이지는 디스크에 동기화하게 하며 , 클린 페이지는 즉시 프리 리스트로 페이지를 옮긴다.

### 버퍼 풀 상태 백업 및 복구

InnoDB 버퍼 풀은 쿼리의 성능에 매우 밀접하게 연결되어 있다. 쿼리 요청이 매우 빈번한 서버를 셧다운했다가 다시 시작하고 서비스를 시작하면 쿼리 처리 성능이 평상시보다 1/10 도 안되는 경우가 대부분일 것이다. 버퍼 풀에 쿼리들이 사용할 데이터가 이미 준비돼 있으므로 디스크에서 데이터를 읽지 않아도 쿼리가 처리될 수 있기 때문이다. 이렇게 디스크의 데이터가 버퍼 풀에 적재돼 있는 상태를 워밍업 이라고 표현하는데 , 버퍼 풀이 잘 워밍업된 상태에서는 그렇지 않은 경우보다 몇십 배의 쿼리 처리 속도를 보이는 것이 일반적이다. 그래서 MySQL 5.5 에서는 점검을 위해 MySQL 서버를 셧다운했다가 다시 시작하는 경우 서비스를 오픈하기 전에 강제 워밍없을 위해 주요 테이블과 인덱스에 대해 풀 스캔을 한 번씩 실행하고 서비스를 오픈 했었다.

하지만 5.6 버전 부터는 버퍼 풀 덤프 및 적재 기능이 도입됐다. 서버 점검이나 기타 작업을 위해 MySQL 서버를 재시작해야하는 경우에는 MySQL 서버를 셧다운 하기전에 inndb_buffer_pool_dump_now 시스템 변수를 이용해 현재 InnoDB 버퍼 풀 상태를 백업할 수 있다. 그리고 MySQL 서버를 다시시작하면 백업된 버퍼풀 상태의 내용을 복구할 수 있다.

반면 버퍼 풀을 다시 복구하는 작업은 상당히 많은 디스크 읽기를 필요로 하기 때문에 버퍼 풀 복구가 실행 중인 상태에서 서비스를 재개하는 것은 좋지 않은 선택일 수 있다.

### 버퍼 풀의 적재 내용 확인

5.6 버전 부터 information_schema 데이터베이스의 innodb_buffer_page 테이블을 이용해 InnoDB 버퍼 풀의 메모리에 어떤 테이블의 페이지들이 적재돼 있는지 확인할 수 있다. 하지만 InnoDB 버퍼 풀이 큰 경우에는 테이블 조회가 상당히 큰 부하를 일으키면서 서비스 쿼리가 많이 느려지는 문제가 있었다. 

이런 문제를 8.0 에서는 information_schema 데이터베이스에 innodb_cached_indexes 테이블이 새롭게 추가되었고, 인덱스별로 페이지가 얼마나 InnoDB 버퍼 풀에 적재돼 있는지 확인할 수 있따.

## Double Write Budffer

InnoDB 엔진의 리두 로그는 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록한다.  이로 인해 InnoDB 엔진에서 더티 페이지를 디스크 파일로 플러시 할 때 일부만 기록되는 문제가 발생하면 그 페이지 내용은 복구할 수 없을 수도 있다. 이렇게 페이지가 일부만 기록되는 현상을 **파셜 페이지 또는 톤 페이지**라고 하는데 이런 현상은 하드웨어의 오작동이나 시스템 비정상 종료 등으로 발생할 수 있다.

InnoDB 엔진에서는 이와 같은 문제를 막기 위해 Double-Write 기법을 사용한다. 

실제 데이터 파일에 변경 내용을 기록하기 전에 더티페이지를 우선 묶어서 한 번의 디스크 쓰기로 시스템 테이블 스페이스의 DoubleWrite 버퍼에 기록한다. 그리고 InnoDB 엔진은 각 더티 페이지를 파일의 적당한 위치에 하나씩 랜덤으로 쓰기를 실행한다.

이렇게 시스템 테이블스페이스의 DoubleWrite 버퍼 공간에 기록된 변경 내용은 실제 데이터 파일에 더티 페이지가 정상적으로 기록되면 더이상 필요 없어진다. 즉 , DoubleWrite 버퍼의 내용은 실제 데이터 파일의 쓰기가 중간에 실패할 때만 원래 목적으로 사용된다.

만약 A,B 페이지는 정상적으로 기록됬지만 C 페이지가 기록되는 도중에 운영체제가 비정상 종료가 되었다고 가정해보자. 그러면 InnoDB 에닞ㄴ은 재시작될 때 항상 DoubleWrite 버퍼의 내용과 데이터 파일의 페이지를 모두 비교해서 다른 내용을 담고 있는 페이지가 있으면 DoubleWrite 버퍼의 내용을 데이터 파일의 페이지로 복사한다.

DoubleWrite 버퍼는 데이터의 안정성을 위해 자주 사용되는데 HDD 처럼 자기 원판이 회전하는 저장 시스템에서는 한번 순차 디스크 쓰기를 하는 것이기 때문에 별로 부담이 되지 않지만, SSD 처럼 랜덤 IO 나 순차 IO 비용이 비슷한 저장 시스템에서는 부담스럽다. 하지만 데이터의 무결성이 매우 중요한 서비스에서는 DoubleWrite 의 활성화를 고려하는 것이 좋다. 

## 언두 로그

InnoDB 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML 로 변경되기 이전의 버전의 데이터를 별도로 백업한다. 이렇게 백업된 데이터를 언두 로그라고한다. 

- 트랜잭션 보장
    
    트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야하는데 ,이때 언두 로그 백업해 둔 이전 버전의 데이터를 이용해 복구한다.
    
- 격리 수준 보장
    
    특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경 중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어서 반환한다.
    

언두 로그는 매우 중요한 역할을 담당하지만 관리 비용도 많이 필요하다. 

### 언두 로그 레코드 모니터링

언두 로그의 데이터가 어떻게 저장되고 어떤 목적으로 사용되는지 살펴보자, 언두 영역은 INSERT , UPDATE ,DELETE 같은 문장으로 데이터를 변경했을 대 변경되기 전의 데이터를 보관하는 곳이다.

예를 들어 `UPDATE member SET name = ’홍길동’ WHERE member_id = 1`

위 문장이 실행되면 트랜잭션을 커밋하지 않아도 실제 데이터 파일 내용은 변경된다. 그리고 변경되기 전 갑이 최준영이라면 언두 영역에는 최준영이라는 값이 백업되어 있는 것이다. 이 상태에서 사용자가 커밋하면 현재 상태가 유지되고 롤백하면 언두 영역의 백업된 데이터를 다시 데이터 파일로 복구한다.

언두 로그 데이터는 크게 두 가지 용도로 사용되는데 , 첫 번째 용도가 바로 위에서 언급한 트랜잭션 롤백 대비용이다. 두 번째 용도는 트랜잭션 격리 수준을 유지하면서 높은 동시성을 제공하는데 있다. 트랜잭션 격리 수준이라는 개념이 있는데 , **이는 동시에 여러 트랜잭션이 데이터를 변경하거나 조회할 때 트랜잭션의 작업 내용이 다른 트랜잭션에 어떻게 보일지 결정하는 기준이다.** 

서비스 중인 MySQL 서버에서 활성 상태의 트랜잭션이 장시간 유지되는 것은 성능상 좋지 않다. 그래서 MySQL 서버의 언두 로그 레코드가 얼마나 되는지 모니터링하는 것은 좋은데 MySQL 서버의 언두 로그 레코드 건수를 확인할 수 있다.

### 언두 테이블스페이스 관리

**언두 로그가 저장되는 공간을 언두 테이블스페이스라고 한다.**하지만 시스템 테이블스페이스의 언두 로그는 모두 시스템 테이블 스페이스에 관리되었고 서버가 초기화될 때 생성되기 때문에 확장의 한계가 있었다. 5.6 버전부터는 innodb_undo_tablespaces 시스템 변수를 2보다 큰 값으로 설정하면 InnoDB엔진은 더이상 언두 로그 시스템 테이블 스페이스에 저장하지 않고 별도의 언두 로그 파일을 사용한다. 

8.0 버전부터는 항상 시스템 테이블스페이스 외부의 별도 로그 파일에 기록되도록 개선되었다.

## 체인지 버퍼

RDBMS에서 레코드가 INSERT 되거나 UPDATE 될 때는 데이터 파일을 변경하는 작업 뿐만아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요하다. 그런데 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 이 작업은 상당히 많은 자원을 소모하게 된다. 그래서 InnoDB 는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 상당히 많은 자원을 소모하게 된다. 그래서 InnoDB 는 변경해야할 인덱스 페이지가 버퍼풀에 있으면 바로 업데이트를 수행하지만 그렇지 않고 디스크로부터 읽어와서 업데이트를 해야 한다면 이를 즉시 실행하지 않고 임시 공간에 저장해두고 사용자에게 결과를 반환하는 형태로 성능을 향상시키게 되는데 이때 사용하는 임시메모리 공간을 **체인지 버퍼**라고한다.

사용자에게 결과를 전달하기 전에 반드시 중복 여부를 체크해야하는 유니크 인덱스는 체인지 버퍼를 사용할 수 없다. 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합되는데 이 스레드를 체인지 버퍼 머지 스레드라고한다. 5.5 이전 버전까지는 INSERT 작업에 대해서만 이러한 버퍼링이 가능했는데 5.5 부터는 조금씩 개선되면서 8.0 에서는 INSERT , UPDATE , DELETE 로 인해 키를 추가하거나 삭제하는 작업에 대해서도 버퍼링이 될 수 있게 개선되었다. 

체인지 버퍼는 InnoDB 버퍼풀로 설정된 메모리 공간의 25 % 까지 사용할 수 있게 설정돼 있으며 필요에 따라 더 높힐 수도 있다.

## 리두 로그 및 로그 버퍼

리두 로그는 트랜잭션의 4가지 요소인 ACID 중에서 D 에 해당하는 영속성과 밀접하게 연관되어 있다.

서버가 비정상종료되었을때 데이터파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치이다.

MYSQL 서버를 포함한 대부분 데이터베이스 서버는 데이터 변경내용을 로그에 먼저 기록한다. `WAL`

거의 모든  DBMS 에서 데이터파일은 쓰기보다 읽기 성능을 고려한 자료구조를 가지고 있기 때문에 데이터 파일 쓰기는 디스크의 랜덤 엑세스가 필요하다. 그래서 변경된 데이터를 데이터 파일에 기록하려면 상대적으로 큰 빙용이 필요하다. 이로 인한 성능 저하를 막기위해 데이터베이스 서버는 쓰기 비용이 낮은 자료구조를 가진 리두 로그를 가지고 있으며 비정상 종료가 발생하면 리두 로그의 내용을 이용해 데이터 파일을 다시 서버가 종료되기 직전의 상태로 복구한다. 데이터베이스 서버는 ACID 도 중요하지만 성능도 중요하기 때문에 데이터 파일뿐만 아니라 리두 록를 버퍼링할 수 있는 InnoDB 버퍼 풀이나 리두 로그를 버퍼링 할 수 있는 로그 버퍼와 같은 자료구조도 가지고 있다.

MySQL 이 비정상 종료되는 경우 InnoDB 엔진의 데이터파일은 다음과같은 두가지 일관되지 않은 데이터를 가질 수 있다.

1. 커밋됐지만 데이터파일에 기록되지 않은 데이터
2. 롤백됐지만 데이터파일에 이미 기록된 데이터

1번의 경우 리두 로그에 저장된 데이터를 데이터 파일에 다시 복사하기만 하면 된다. 하지만 2번의 경우에는 리두 로그로는 해결할 수 없는데 이때는 변경되기 전 데이터를 가진 언두 로그의 내용을 가져와 데이터 파일에 복사하면 된다. 그렇다고 하더라도 리두 로그가 전혀 필요하지 않은 것은 아니다. 최소한 커밋 , 롤백 여부, 트랜잭션 실행 중간이었는지 확인하기 위해서 필요하다.

데이터베이스 서버에서 리두 로그는 트랜잭션이 커밋되면 즉시 디스크로 기록되도록 시스템 변수를 설정하는 것을 권장한다. 그리고 당연히 그렇게 돼야만 서버가 비정상 종료가 되었을 때 직전까지의 트랜잭션 커밋 내용이 리두 로그에 기록될 수 있고 ,그 리두 로그를 이용해 장애 직전 시점까지 복구가 가능해진다. 

하지만 이처럼 트랜잭션 커밋될 때마다 리두 로그를 디스크에 기록하는 작업은 많은 부하를 유발한다.그래서 InnoDB 엔진에서 리두 로그를 어느 주기로 디스크에 동기화할지를 결정하는 innodb_flush_log_at_trx_commit 시스템 변수를 제공한다.  이 값이 0이라면 1초에 한번씩 리두 로그를 디스크로 기록하고 동기화 실행한다.

이 값이 1이라면 매번 트랜잭션이 커밋될 때마다 디스크로 기록되고 동기화까지 수행된다. 그래서 트랜잭션이 커밋되면 해당 트랜잭션에서 변경한 데이터는 사라진다.

이값이 2라면 매번 트랜잭션이 커밋될 때마다 디스크로 기록은 되지만 실제로 동기화 작업은 1초에 한번씩 일어난다.일단 커밋되면 변경 내용이 운영체제의 메모리 버퍼로 기록되는 것이 보장되고 MySQL 서버가 비정상종료되었다고 하더라고 운영체제가 정상적으로 작동한다면 해당 트랜잭션의 데이터는 사라지지 않는다. 

### 리두 로그 활성화 및 비활성화

InnoDB 엔진의 리두 로그는 하드웨어나 소프트웨어 등 여러가지 문제점으로 MySQL 서버가 비정상 종료되었을때 데이터 파일에 기록되지 못한 트랜잭션을 복구하기 위해 항상 활성화돼있다.MySQL 서버에서 트랜잭션이 커밋되어도 데이터 파일은 즉시 디스크로 동기화 되지 않는 반면 리두 로그는 항상 디스크로 기록된다.

하지만 8.0 부터는 수동으로 리두 로그를 비활성화할 수 있게 되었다. 데이터를 복구하거나 대용량 데이터를 한번에 적재하는 경우 리두 로그를 비활성화하여 데이터의 적재 시간을 단축시킬 수 있다.

## 어댑티브 해시 인덱스

어댑티브 해시 인덱스는 사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스이며 , 사용자는 innodb_adaptive_hash_index 시스템 변수를 이용해서 어댑티브 해시 인덱스 기능을 활성화하거나 비활성화할 수 있다.

어댑티브 해시 인덱스는 B-Tree 검색 시간을 줄여주기 위해 도입된 기능이다. InnoDB 스토리지 엔진은 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만들고, 필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 데이터 페이지를 즉시 찾아갈 수 있다. B-Tree 를 루드 노드부터 리프 노드까지 찾아가는 비용이 없어지고 그만큼 CPU 가 적은 일을하지만 쿼리 성능은 빨라진다. 그와 동시에 컴퓨터는 더 많은 쿼리를 동시에 처리할 수 있게된다. 

해시 인덱스는 인덱스 키 값과 해당 인덱스 키 값이 저장된 데이터 페이지 주소의 쌍으로 관리되는데 , 인덱스 키 값은 `B-Tree 인덱스의 고유번호`와 `B-Tree의 실제 키 값` 조합으로 생성된다. 어댑티브 해시 인덱스 키 값에 `B-Tree 인덱스 고유번호`가 포함되는 이유는  InnoDB 엔진에서 어댑티브 해시 인덱스는 하나만 존재하기 때문이다. 즉 모든 B-Tree 인덱스에 대한 어댑티브 해시 인덱스가 하나의 해시 인덱스에 저장되며 특정 키 값이 어느 인덱스에 속한 것인지도 구분해야하기 때문이다. 그리고 데이터 페이지 주소는 실제 키 값이 저장된 데이터 페이지의 메모리 주소를 가지는데 이는 InnoDB 버퍼 풀에 로딩된 페이지의 주소를 의미한다. 그래서 어댑티브 해시 인덱스는 버퍼 풀에 올려진 데이터 페이지에 대해서만 관리되고 버퍼 풀에서 해당 데이터 페이지가 겂으면 어댑티브 해시 인덱스에서도 해당 페이지 정보는 사라진다.

어댑티브 해시 인덱스를 사용함으로써 쿼리 처리량을 두배이상 이끌어낼 수 있었다. 8.0 이전 버전에서는 어댑티브 해시 인덱스는 하나의 메모리 객체인 이유로 어댑티브 해시 인덱스의 경합이 상당히 심했다. 하지만 8.0 부터는 내부 잠금 경합을 줄이기 위해 어댑티브 해시 인덱스의 파티션 기능을 제공한다. 기본 값은 8개 이며 , 어댑티브 해시 인덱스가 성능에 많은 도움이 된다면 더 많이 설정하여 인덱스 내부 경합을 줄이는데 많은 도움이 될 것이다.

하지만 어댑티브 해시 인덱스를 의도적으로 비활성화하는 경우도 많다.

- 디스크 읽기가 많은 경우
- 특정 패턴의 쿼리가 많은 경우(조인이나,LIKE 패턴 검색)
- 매우 큰 데이터를 가진 테이블 레코드를 폭넓게 읽는 경우

단순히 어댑티브 해시 인덱스가 도움이 될지 아닐지를 판단하기는 어렵다. 하지만 확실한 것은 어댑티브 해시 인덱스는 데이터 페이지를 버퍼 풀 내에서 접근하는 것을 더 빠르게 만드는 것이기 때문에 데이터 페이지를 디스크에서 읽어오는 경우가 빈번한 경우 별로 도움이 되지 않는다는 점이다. 또한 어댑티브 해시 인덱스 또한 저장 공간인 메모리를 사용하며 때로는 상당히 많은 공간을 사용할 수 있다.

어댑티브 해시 인덱스는 테이블의 삭제 작업에도 많은 영향을 미친다. 어떤 테이블의 인덱스가 어탭티브 해시 인덱스에 적재돼 있다고 가정해보자. 이때 테이블을 삭제하거나 변경하려고하면 InnoDB엔진은 이 테이블이 가진 모든 데이터 페이지의 내용을 어댑티브 해시 인덱스에서 제거해야한다. 이로인해 테이블이 삭제되거나 스키마가 변경되는 동안 상당히 많은 CPU 자원을 사용하고 그만큼 데이터베이스 서버의 처리 성능이 저하된다.

어댑티브 해시 인덱스가 서비스 패턴에 맞게 도움이 되는지 아니면 불필요한 오버헤드만 만들고 있는지를 판단해야하는데 , 가장 쉬운 방법은 MySQL 서버의 상태값들을 살펴보는 것이다. MySQL 서버에서 어댑티브 해시 인덱스는 기본적으로 활성화돼 있기 때문에 상태 값들이 유효한 통계를 가지고 있을 것이다. 

`1.03 hash searchs/s , 2.64 non-hash searches` 를 보면 3.67 초 중에서 1.03 은 어댑티브 해시 인덱스를 사용했다는 것을 알 수 있다.

어댑티브 해시 인덱스의 효율은 검색 횟수가 아니라 해시 인덱스 히트율과 어댑티브 해시 인덱스가 사용중인 메모리 공간, CPU 사용량을 종합해서 판단해야한다. 어댑티브 해시 인덱스가 사용 중인 메모리 사용량이 높다면 그리고 히트율이 낮다면 어댑티브 해시 인덱스를 비활성화해서 InnoDB 버퍼 풀이 더 많은 메모리를 사용할 수 있도록 유도하는 것도 좋은 방법이다. 이런한 값은 performance_schema 를 이용해서 확인 가능하다.

## MySQL 로그 파일

MySQL 로그 파일을 이용하면 상태나 부하를 일으키는 원인을 쉽게 찾아서 해결할 수 있다.무엇보다 MySQL 서버에 문제가 생겼을 때는 다음에 설명하는 로그 파일들을 자세히 확인하는 습관을 들일 필요가 있다.

### 에로 로그 파일

MySQL 이 실행되는 도중에 발생하는 에러나 경고 메시지가 출력되는 로그 파일이다. 에로 로그 파일의 위치는 

MySQL 설정 파일(my.cnf) 에서 log_error 라는 이름의 파라미터로 정의된 경로에 생성된다.

- MySQL이 시작하는 과정과 관련된 정보성 및 에러 메시지
    
    MySQL 의 설정 파일을 변경하거나 데이터베이스가 비정상적으로 종료된 이후 다시 시작하는 경우네는 반드시 MySQL 에로 로그 파일을 통해 설정된 변수의 이름이나 값이 명확하게 설정되고 의도한 대로 적용되었는지 확인해야한다. 새로 변경하거나 추가한 파라미터에 대한 특별한 에러나 경고성 메시지가 없다면 정상적으로 적용된 것으로 판단하면 된다.그렇지 않고 무시된 경우에는 MySQL 서버가 정상적으로 기동하지만 적용되지 않았음을 의미한다.
    
- 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지
    
    InnoDB의 경우에는 MySQL서버가 비정상적 또는 강제적으로 종료됐다면 다시 시작하면서 완료되지 못한 트랜잭션을 정리하고 디스크에 기록되지 못한 데이터가 있다면 다시 기록하는 재처리 작업을 진행하게 된다. 이 과정에 대한 간단한 메시지가 출력되는데 , 간혹 문제가 있어서 복구되지 못하는 경우 에러 메시지를 출력하고 다시 종료될 것이다.
    
- 쿼리 처리 도중에 발생하는 문제에 대한 에러메시지
    
    쿼리 도중 발생하는 문제점은 사전 예방이 어려우며 , 주기적으로 에러 로그 파일을 검토하는 과정에서 알게된다. 쿼리 실행 도중 발생한 에러나 복제에서 문제가 될 만한 쿼리에 대한 경고 메시지가 에러 로그에 기록된다
    
    그래서 자주 에러 로그 파일을 검토하는 것이 데이터베이스의 숨겨진 문제점을 해결하는데 도움이 될 것이다.
    
- 비정상적으로 종료된 커넥션 메시지
    
    어떤 데이터베이스 서버의 로그 파일을 보면 이 메시지가 상당히 많이 누적돼 있는 경우가 있다. 클라이언트 어플리케이션에서 정상적으로 접속 종료를 하지 못하고 프로그램이 종료되는 경우 MySQL 서버 로그 파일에 이런 내용이 기록된다.이런 메시지가 많이 기록된다면 어플리케이션의 커넥션 종료 로직을 검토해볼 필요가 있다.
    
- InnoDB의 모니터링 또는 상태 조회 명령의 결과 메시지
    
    InnoDB 의 테이블 모니터링이나 락 모니터링 , 또는 InnoDB 의 엔진 상태를 조회하는 명령은 상대적으로 큰 메시지를 에러 로그 파일에 기록한다. InnoDB 의 모니터링을 활성화 상태로 만들어 두고 그대로 두면 파일 시스템 공간을 다 사용해 버릴지도 모른다. 모니터링 한 후에는 다시 비활성화해서 에러 로그 파일이 커지지 않게 해야한다.
    
- MySQL 의 종료메시지
    
    MySQL 서버가 가끔 종료되어 있을 때가 있는데 그때 에러 로그 파일에서 MySQL 이 마지막으로 종료되면서 출력한 메시지를 확인하는 것이 좋다.
    

### 제너럴 쿼리 로그 파일

가끔 MySQL 서버에서 실행되는 쿼리로 어떤 것들이 있는지 전체 목록을 뽑아서 검토해 볼 필요가 있는데 이때는 쿼리 로그를 활성화해서 쿼리를 쿼리 로그 파일에 기록하게 한 다음 , 그 파일을 검토하면 된다. 쿼리 로그 파일에는  시간 단위로 실행됐던 쿼리의 내용이 모두 기록된다. 슬로우 쿼리 로그와는 다르게 제너럴 쿼리 로그는 실행되기 전에 MySQL이 쿼리 요청을 받으면 바로 기록하기 대문에 쿼리 실행 중에 에러가 발생해도 일단 로그 파일에 기록된다.

쿼리 로그 파일의 경로는 general_log_file 이라는 파라미터에 설정돼 있다. 또한 쿼리 로그를 파일이 아닌 테이블에 저장하도록 설정할 수 있으므로 이 경우에는 파일이 아닌 테이블을 SQL 조회해서 검토해야한다.

쿼리 로그를 파일로 저장할지 테이블로 저장할지는 log_output 파라미터로 결정된다.

### 슬로우 쿼리 로그

MySQL 서버의 쿼리 튜닝은 크게 서비스가 적용되기 전에 전체적인 튜닝을 하는 경우와 서비스 운영 중에 MySQL 서버의 전체적인 성능 저하를 검사하거나 정기적인 점검을 위한 튜닝으로 나눌 수 있다.

후자의 경우 어떤 쿼리가 문제의 쿼리인지 판단하기 어렵다. 이런 경우에 서비스에서 사용되는 쿼리 중에서 어떤 쿼리가 문제인지를 판단하는데 슬로우 쿼리 로그가 도움된다.

슬로우 쿼리 로그 파일에는 long_query_time 시스템 변수에 설정한 시간 이상의 시간이 소요된 쿼리가 모두 기록된다. 슬로우 쿼리 로그는 MySQL 이 쿼리를 실행한 후 실제 소요된 시간을 기준으로 슬로우 쿼리 로그에 기록할지 여부를 판단하기 때문에 반드시 쿼리가 정상적으로 실행이 완료돼야 슬로우 쿼리 로그에 기록될 수 있다.

가끔 InnoDB 테이블에 대한 SELECT 쿼리의 경우에도 Lock_time 이 상대적으로 큰 값이 발생할 수 있는데,이는 InnoDB의 레코드 수준의 잠금이 아닌 MySQL 엔진 레벨에서 설정한 테이블 잠금 때문일 가능성이 높다. 그래서 InnoDB 테이블에만 접근하는 쿼리 문장의 슬로우 쿼리 로그에서는 Lock_time 값은 튜닝이나 쿼리 분석에 별로 도움이 되지 않는다.

일반적으로 슬로우 쿼리 또는 제너럭 로그 파일의 내용이 많아져 직접 쿼리를 하나씩 검토하기에는 시간이 오래 걸리거나 어느 쿼리를 집중적으로 튜닝해야할지 식별하기 어려울 수 있다. 이런 경우 Percona 에서 개발한 Percona Toolkit의 pt-query-digest 스크립트를 이용하면 쉽게 빈도나 처리 성능별로 쿼리를 정렬해서 살펴볼 수 있다. `pt-query-digest —type=’genlog’ general.log > parsed_general.log`

## Reference
- [Real MySQL 8.0(1권)](https://www.yes24.com/Product/Goods/103415627)
