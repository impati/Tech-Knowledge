

## 개요

### 쿼리 실행 절차

MySQL 서버에서 쿼리가 실행되는 과정은 크게 세단계로 나눌 수 있다.

1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.
2. SQL 파싱 정보를 확인하며 어떤 테이블을 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

첫 번쨰 단계를 SQL 파싱으로고하며 MySQL 서버의 SQL 파서가 모듈로 처리한다. 또한 이 단계에서 문법적으로 잘못된 부분이 걸러지고 SQL 파스 트리가 만들어진다.

두 번째 단계는 SQL 파스 트리를 참조하여 불필요한 조건 제거 및 복잡한 연산의 단순화 , 여러 테이블 조인이 있을 때 어떤 순서로 테이블을 읽을지 , 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정 , 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야하는 지 결정을 처리한다. 이 단계는 최적화 및 실행 계획 수립 단계이며 MySQL 에서는 옵티마이저에서 처리한다. 이 단계를 통해 실행 계획이 만들어지며 

세 번째 단계에서 실행 계획으로 레코드들을 가져온다.

### 옵티마이저의 종류

옵티마이저는 데이터베이스 서버에서 두뇌와 같은 역할을 담당하며 **비용 기반 최적화 방법**과 **규칙 기반 최적화 방법**으로 나눌 수 있다. 

비용 기반 최적화는 쿼리를 처리하기 위한 다양한 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획 별 비용을 산출하고 이 비용이 최소가 되는 처리 방식을 선택해 최종적으로 쿼리를 실행한다.

규칙 기반 최적화는 대상 테이블의 레코드 건수나 선택도를 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식이다.이 방식에서는 통계 정보의 정보를 조사하지 않고 실행 계획을 수립하기 때문에 같은 쿼리에 대해서는 항상 같은 실행 계획을 만들어낸다.

## 기본 데이터 처리

MySQL 서버를 포함한 모든 RDMS 는 데이터를 정렬하거나 그루핑하는 등의 기본 데이터 가공 기능을 가지고 있다. 

### 풀 테이블 스캔과 풀 인덱스 스캔

풀 테이블 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다. MySQL 옵티마이저는 테이블의 레코드 수가 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우 , WHERE 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우 , 조건 일치 레코드 건수가 너무 많은 경우에는 풀 테이블 스캔을 한다.

InnoDB 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 **리드 어헤드** 작업이 시작된다. 리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 두는 것을 의미한다.

즉 , 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다. 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면 되므로 쿼리가 상당히 빨리 처리된다.

MySQL 서버에서는 innodb_read_ahead_threshold 시스템 변수를 이용해 InnoDB 엔진이 언제 리드 어헤드를 시작할지 임계점을 설정 할 수 있다.

리드 어헤드는 풀 테이블 스캔에서만 사용되는 것이 아니라 풀 인덱스 스캔에서도 동일하게 사용된다. 풀 테이블 스캔이 테이블을 처음부터 끝까지 스캔하는 것을 의미하듯이 풀 인덱스 스캔은 인덱스를 처음부터 끝까지 스캔하는 것을 의미한다.

## 병렬 처리

여기서 병렬 처리는 하나의 쿼리를 처리하기 위해 여러 스레드가 작업을 나누어 동시에 처리한다는 것을 의미한다.

아직 MySQL 서버에서는 쿼리를 여러 개의 스레드를 이용해 병렬로 처리하게 하는 힌트나 옵션은 없다. 8.0 버전 부터는 아무런 WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리할 수 있다.

## ORDER BY 처리

레코드 1 ~ 2건을 가져오는 쿼리를 제외하면 대부분의  SELECT 쿼리에서 정렬은 필수적으로 사용된다. 정렬을 처리하는 방법은 인덱스를 이용하는 방법과  쿼리가 실행될 때 Filesort 라는 별도의 처리를 이용하는 방법으로 나눌 수 있다.

MySQL 서버에서 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 Extra 칼럼에 “Using filesort” 메시지가 표시되는지 여부로 알 수 있따.

### 소트 버퍼

MySQL 은 정렬을 수행하기 위해 별도의 메모리 공간을 할당 받아서 사용하는데 이 메모리 공간을 소트 버퍼라고 한다. 소트 버퍼는 정렬이 필요한 경우에만 할당되며 버퍼의 크기는 정렬해야할 레코드 크기에 따라 가변적으로 증가하지만 최대 사용 가능한 소트 버퍼의 공간을 설정할 수 있다. 소트 버퍼를 위한 메모리 공간은 쿼리 실행이 완료되면 즉시 시스템으로 반납된다.

정렬해야할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면 MySQL 은 정렬해야 할 레코드를 여러 조각으로 나눠서 처리하는데 이 과정에서 임시 저장을 위해 디스크를 사용한다. 메모리 소트 버퍼에서 정렬을 수행하고 그 결과를 임시로 디스크에 기록해 둔다. 그 다음 레코드를 가져와서 다시 정렬 후 반복적으로 디스크에 임시 저장한다. 이처럼 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행해야한다. 이 병합 작업을 멀티 머지 라고 표현한다. 이 작업이 모두 디스크쓰기와 읽기를 유발하며 레코드 수가 많을수록 이 반복 작업의 횟수가 많아진다. 소트 버퍼를 크게 할당하는 것이 큰 도움이 되지는 않는다 더 큰 공간 할당에 대한 오버헤드가 발생하기 때문이다.

정렬을 위해 사용되는 소트 버퍼는 세션 메모리영역에 해당되어 여러 클라이언트가 공유할 수 있는 영역이 아니라 정렬 작업이 많을수록 소트 버퍼로 소비되는 메모리 공간이 커짐을 의미한다. 

### 정렬 알고리즘

레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 칼럼만 소트 버퍼에 담을지에 따라 싱글 패스 , 투 패스 2가지 정렬모드로 나눌 수 있다. 정렬을 수행하는 쿼리가 어떤 정렬 모드를 사용하는지는 옵티마이저 트레이스 기능으로 확인할 수 있다.

 

```sql
SET OPTIMIZER_TRACE="enabled=on",END_MARKERS_IN_JSON=on;

... 정렬 쿼리 후

SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE; 
```

출력된 내용에서 filesort_summary 색션의 sort_algorithm 필드에 정렬 알고리즘이 표시되고 , sort_mode 에는 다음 3가지가 표시된다.

- <sort_key,rowid> : 정렬 키와 레코드의 로우 아이디만 가져와서 정렬하는 방식
- <sort_key,addtional_fields> : 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로 레코드의 칼럼들은 고정 사이즈로 메모리 저장
- <sort_key,packed_addtional_fields> : 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로 레코드의 칼럼들은 가변 사이즈로 메모리 저장

이때 정렬 키와 레코드의 로우 아이디만 가져와 정렬하는 방식을 “투 패스” 정렬 방식이라고 하며 나머지는 “싱글 패스” 정렬 방식이라고한다.

싱글 패스 정렬 방식을 사용하면 정렬에 필요하지 않은 칼럼까지 모두 읽어 소트 버퍼에 담아 정렬을 수행한다. 그리고 정렬이 완료되면 정렬 버퍼의 내용을 그대로 클라이언트에게 전달한다.

반면 투 패스 정렬 방식은 정렬 대상 컬럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT 칼럼을 가져오는 방식으로 싱글 패스 정렬 방식이 사용되기 이전부터 사용하던 방식이다. 8.0 에서도 특정 조건(레코드 크기가 큰 경우)에서는 투 패스 정렬 방식을 사용한다.

투 패스 정렬 방식은 테이블을 두 번 읽어야하기 때문에 불합리하지만 싱글 패스 정렬 방식은 더 많은 소트 버퍼 공간이 필요하거나 멀티 머지 작업이 더 많이 발생하여 디스크 읽기와 쓰기가 자주 발생한다. 그럼에도 불구하고 현재는 싱글 패스 정렬 방식을 주로 사용한다.

> SELECT 쿼리에서 꼭 필요한 컬럼만 조회하지 않고 모든 칼럼(*) 가져오도록 개발할 때가 많다. 하지만 이는 정렬 버퍼를 몇 배에서 몇십배까지 비효율적으로 사용할 가능성이 크다. SELECT 쿼리에서 꼭 필요한 컬럼만 조회하도록 쿼리를 작성하는 것이 좋다고 권장하는 이유는 바로 이런 이유 때문이다.
>
