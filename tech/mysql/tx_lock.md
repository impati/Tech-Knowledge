트랜잭션은 작업의 완전성을 보장해 주는 것이다. 즉  논리적인 작업 셋을 모두 완벽하게 처리하거나 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능이다.

잠금과 트랜잭션은 서로 비슷한 개념 같지만 사실 **잠금은 동시성을 제어하기 위한 기능**이고 트랜잭션은 데이터의 정합성을 보장해주기 위한 기능이다.

하나의 회원 정보 레코드를 여러 케넥션에서 동시에 변경하려고 할때 잠금이 없다면 하나의 데이터를 여러 커넥션에서 동시에 변경할 수 있게 된다. 결과적으로 해당 레코드값은 예측할 수 없는 상태가 된다. 잠금은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할을 한다. 격리 수준이라는 것은 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨을 의미한다.

## MySQL 에서의 트랜잭션

트랜잭션은 하나의 논리적인 작업 셋에 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100 % 적용되거나 아무것도 적용되지 않아야함을 보장 해주는 것이다. **즉 ,작업의 원자성을 보장해주는 것이다.**

트랜잭션이 보장되지 않았을 때 발생하는 부분 업데이트는 테이블 데이터의 정합성을 맞추는데 상당히 어려운 문제를 만들어낸다.

트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 특히 트랜잭션이 유지되는 동안 네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제해야한다. 그렇지 않으면 서버가 높은 부하 상태로 빠지거나 동시 처리에 심각한 문제가 생길 수가 있다.

## MySQL 엔진의 잠금

MySQL 엔진에서는 테이블 데이터 동기화를 위한 테이블 락 이외에도 테이블의 구조를 잠그는 메타 데이터락 그리고 사용자의 필요에 맞게 사용할 수 있는 네임드락 기능도 존재한다.

### 글로벌 락

MySQL 에서 제공하는 잠금 가운데 가장 범위가 크다. 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT 를 제외한 대부분의 DDL , DML 문장을 실행하는 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남는다. 글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체이며 , 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미친다. 

### 테이블 락

테이블 단위로 설정되는 잠금이며 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다. 

InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경 쿼리로 인해 묵시적인 테이블락이 설정되지 않는다. 설정되어도 DML 쿼리에서는 무시되고 스키마를 변경하는 쿼리DDL 의 경우에만 영향을 마친다.

### 네임드 락

GET_LOCK() 이라는 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다. 이 잠금의 특징은 대상 테이블이나 레코드 같은 데이터베이스 개체가 아니라 단순히 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금이다. 여러 클라이언트가 상호 동기화를 처리해야할 때 사용된다.

또한 여러 레코드에 대해 락을 거는 행위보다 네임드락을 사용해서 락을 건다면 좋은 해결방법이 될 수 있다.

### 메타데이터 락

메타데이터 락은 데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다. 메타데이터 락은 명시적으로 획득하거나 해제할 수 있는 것이 아니다. 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다.

## InnoDB 스토리지 엔진 잠금

InnoDB 스토리지 엔진은 MySQL 에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다. InnoDB 의 트랜잭션과 잠금 ,잠금 대기 중인 트랜잭션의 목록을 조회할 수 있다. information_schema 의 INNODB_TRX , INNODB_LOCKS , INNODB_LOCK_WAITS 등등

InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공하며 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드락이 페이지 락으로 ,또는 테이블 락으로 레벨업 되는 경우는 없다. InnoDB 스토리지 엔진에서는 레코드 락뿐 아니라 레코드와 레코드 사이의 간격을 잠그는 GAP 락이라는 것이 존재한다.

### 레코드 락

레코드 자체만을 잠그는 것을 레코드 락이라고하며 , InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 점이다. 인덱스가 하나도 없는 테이블이라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다. 

InnoDB 에서는 대부분 보조 인덱스를 이용한 변경 작업은 이어서 설명할 넥스트 키 락 또는 갭 락을 사용하지만 프라이머리 키 또는 유니트 인덱스에 대한 변경 작업에서는 갭에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 건다.

### 갭 락

`Gap Lock` 은 인덱스 레코드 간의 Gap 혹은 첫 번째 또는 마지막 인덱스 레코드 전/후의 Gap 에 설정되는 Lock 입니다. Gap 자체에 Lock 이 설정되었기 때문에 삽입하려는 곳의 값 존재 여부와 관계 없이 다른 트랜잭션에서 데이터를 삽입할 수 없습니다.갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어합니다.
Gap Lock 은 내부적으로 Shared Lock 형태만 존재한다. 다른 트랜잭션에서 새로운 레코드가 INSERT 되는 것을 막는 것이 주 목적이기 때문에 , 그래서 UPDATE , DELETE 문장에 의해서 GAP LOCK 끼리 경합이 발생하지 않는 것이다.

### 넥스트 키 락

레코드 락과 갭 락을 합쳐 놓은 형태의 잠금을 넥스트 키 락이라고 한다. MySQL 서버에서는 REPEATABLE READ 격리 수준을 사용해야한다. 넥스트 키락과 갭락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리는 일이 자주 발생한다. 

### 자동 증가 락

MySQL 에서는 자동 증가하는 숫자값을 추출하기 위해 AUTO_INCREMENT 라는 칼럼 속성을 제공한다.  AUTO_INCREMENT 라는 칼럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우  각 저장되는 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야한다. InnoDB 스토리지 엔진은 이를 위해 내부적으로 자동 증가락이라고하는 테이블 수준의 잠금을 사용한다.

INSERT 와 같은 쿼리에서만 발생하며 DELETE , UPDATE 쿼리에서는 발생하지 않는다. 

자동 증가락은 트랜잭션과 관계 없이 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다.

자동 증가락은 테이블에 단 하나만 존재하기 때문에 두 개의 INSERT 쿼리가 동시에 실행되는 경우 하나의 쿼리가 자동 증가락을 걸면 나머지 쿼리는 이전의 자동 증가락을 기다려야한다.

이를 명시적으로 획득하고 해제하는 방법은 없다 아주 짧은 시간 걸렸다가 해제되는 잠금이라 문제되지 않는다.

하지만 5.1 이상부터는 여러 모드를 사용할 수 있게되었는데 

### 인덱스와 잠금

InnoDB 잠금과 인덱스는 중요한 연관관계가 있다. 레코드를 잠금는 것이 아니라 인덱스를 잠그는 방식으로 처리된다. 즉 변경해야할 레코드를 찾기위해 검색한 인덱스의 레코드를 모두 락을 걸어야한다. 그래서 Update 문장을 위해 적절히 인덱스가 준비되어 있지 않는다면 여러 클라이언트간의 동시성이 상당히 떨어질 수도 있다,.

### 레코드 수준의 잠금 확인 및 해제

InnoDB 스토리지 엔진을 사용하는 테이블의 레코드 수준 잠금은 테이블 수준 잠금보다 복잡하다. 레코드 수준의 잠금은 테이브르이 레코드 각각에 잠금이 걸리므로 그 레코드가 자주 사용되지 않는다면 오랜 기간 동안 잠겨진 상태로 남아 있어도 잘 발견되지 않는다.

MySQL 8.0 버전 부터는 performance_schema 의 data_locks 와 data_lcoks_waits 테이블로 대체되고 있다. 

## MySQL 의 격리 수준

트랜잭션 격리 수준이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다. 크게 `READ UNCOMMITED` , `READ COMMITED` , `REPEATABLE READ` ,`SERIALIZABLE` 이 있다.

더티 리드가 발생하는 `READ UNCOMMITED` 나 , 동시성이 중요한 어플리케이션에서 `SERIALIZABLE` 은 거의 사용되지 않는다.  SQL-99 에 따르면 `REPEATABLE READ` 은 PHANTOM READ 가 발생할 수 있지만 InnoDB 에서는 Gap Lock 으로 인해 거의 발생하지 않는다.

### READ UNCOMMITED

이 격리 수준에서는 각 트랜잭션에서 변경 내용이 COMMIT , ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보인다.  문제가 되는 것은 읽은 값이 Rollback 되더라도 그 값은 다른 트랜잭션에서 이미 읽은 DIRTY READ가 발생할 수 있다는 것이다.

### READ COMMITED

이 격리 수준은 더티 리드가 발생하지 않는다. 어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT 이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있기 때문이다. 이 격리 수준에서는 반복 불가능한 읽기와 유령 읽기가 발생할 수 있는데 이런 문제는 하나의 트랜잭션에서 동일 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되는 문제가 될 수 있다.예를 들어 다른 트랜잭션에서 입금과 출금 처리가 계속 진행될 때 다른 트랜잭션에서 오늘 입금된 금액의 총합을 조회한다고 해보자 그런데 반복가능한 읽기가 보장하지 않기 대문에 총합을 계산하는 SELECT 쿼리마다 다른 결과를 가져오게 될 것이다. 중요한 것은 사용 중인 트랜잭션의 격리 수준에 의해 실행하는 SQL 문장이 어떤 결과를 가져오게 되는지를 정확히 예측할 수 있어야한다는 것이다. 

### REPEATABLE READ

InnoDB 엔진에서 기본으로 사용되는 격리 수준이다. 이 수준에서는 반복 가능한 읽기를 보장한다. InnoDB 엔진은 트랜잭션이 Rollback 될 가능성에 대비해 변경되기 전 레코드를 언두 영역에 백업해두고 실제 레코드를 변경한다. 이러한 방식을 MVCC 라고한다. REPEABLE READ 는 이 MVCC 를 위해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내 동일한 결과를 보여줄 수 있도록 보장한다.

모든 InnoDB 의 트랜잭션은 고유한 트랜잭션 번호를 가지며 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션 번호가 포함돼 있다. 그리고 언두 영역의 백업된 데이터는 InnoDB 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제한다.

### SERIALIZABLE

가장 단순한 격리 수준이면서 가장 엄격한 격리 수준이다. 그만큼 동시 처리 성능도 다른 트랜잭션 격리 수준보다 떨어진다.이 수준에서는 읽기를 위해서 공유 잠금을 획득해야하며 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못한다. 이 격리수준에서는 유령읽기 문제가 발생하지 않는데 , MySQL 에서는 이미 갭락과 넥스트 키락 때문에 발생하지 않으므로 굳이 사용할 필요가 없어보인다.

## Reference
- [Real MySQL 8.0(1권)](https://www.yes24.com/Product/Goods/103415627)
